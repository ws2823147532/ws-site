<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/ws-site/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/ws-site/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/ws-site/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/ws-site/images/logo.svg" color="#222">

<link rel="stylesheet" href="/ws-site/css/main.css">


<link rel="stylesheet" href="/ws-site/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/ws-site/lib/pace/pace-theme-minimal.min.css">
  <script src="/ws-site/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ws2823147532.github.io","root":"/ws-site/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="算法分类十种常见排序算法可以分为两大类：  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   算法复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a">
<meta name="keywords" content="排序算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法学习笔记-排序算法">
<meta property="og:url" content="https://ws2823147532.github.io/post/数据结构与算法学习笔记-排序算法/index.html">
<meta property="og:site_name" content="努力，奋斗">
<meta property="og:description" content="算法分类十种常见排序算法可以分为两大类：  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   算法复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://ws2823147532.github.io/images/排序算法1.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/排序算法.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/冒泡.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/插入排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/选择排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/希尔排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/归并排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/快排.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/堆排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/二叉堆.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/计数排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/基数排序.png">
<meta property="og:image" content="https://ws2823147532.github.io/images/桶排序.png">
<meta property="og:updated_time" content="2020-06-29T17:51:40.125Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法学习笔记-排序算法">
<meta name="twitter:description" content="算法分类十种常见排序算法可以分为两大类：  比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。   算法复杂度 相关概念 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a">
<meta name="twitter:image" content="https://ws2823147532.github.io/images/排序算法1.png">

<link rel="canonical" href="https://ws2823147532.github.io/post/数据结构与算法学习笔记-排序算法/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构与算法学习笔记-排序算法 | 努力，奋斗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/ws-site/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">努力，奋斗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/ws-site/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/ws-site/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/ws-site/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/ws-site/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/ws-site/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/post/数据结构与算法学习笔记-排序算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/ws-site/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构与算法学习笔记-排序算法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-29 08:49:58" itemprop="dateCreated datePublished" datetime="2019-03-29T08:49:58+08:00">2019-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-30 01:51:40" itemprop="dateModified" datetime="2020-06-30T01:51:40+08:00">2020-06-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ws-site/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="算法分类"><a href="#算法分类" class="headerlink" title="算法分类"></a>算法分类</h3><p>十种常见排序算法可以分为两大类：</p>
<ul>
<li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。</li>
<li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li>
</ul>
<p><img src="/images/排序算法1.png" alt="排序算法1"></p>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p><img src="/images/排序算法.png" alt="排序算法"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><strong>稳定</strong>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li><strong>不稳定</strong>：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数</li>
</ul>
<p><a href="https://www.cnblogs.com/onepixel/p/7674659.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O($n^2$)"></a>O($n^2$)</h3><h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否符合大小关系要求。如果不满足就互换位置。一次冒泡至少会让一个元素移动到它应该在的位置，重复n次，就完成了n个元素的排序工作。</p>
<p><img src="/images/冒泡.png" alt="冒泡"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序：从小到大</span></span><br><span class="line"><span class="string">    :param nums:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[j]:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort1</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">      <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums) - <span class="number">1</span> - i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &gt; nums[j + i]:</span><br><span class="line">                nums[j], nums[j + <span class="number">1</span>] = nums[j + <span class="number">1</span>], nums[j]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>]</span><br><span class="line">    print(bubble_sort(nums))</span><br></pre></td></tr></table></figure>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>将一个元素插入一个已经有序的序列，使其依然有序。首先，将原始的序列分为两个子序列，有序的和无序的，然后，从无序的序列中依次拿出一个元素，插入到有序的序列的合适位置，并保持有序的序列依然有序，直到无序的序列中没有元素了。</p>
<p><img src="/images/插入排序.png" alt="插入排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):  <span class="comment"># 遍历无序数组的每一个元素</span></span><br><span class="line">        tmp = nums[i]  <span class="comment"># 待插入元素</span></span><br><span class="line">        j = i - <span class="number">1</span>  <span class="comment"># 待插入子数组</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):  <span class="comment"># 从后往前遍历待插入子数组</span></span><br><span class="line">            <span class="keyword">if</span> tmp &gt;= nums[j]: <span class="keyword">break</span>  <span class="comment"># tmp大于等于当前元素，停止遍历   </span></span><br><span class="line">                					<span class="comment"># 相等元素不会改变其相对位置，故是稳定的</span></span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]  <span class="comment"># 将nums[j]后移1个位置</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = tmp  <span class="comment"># 插入待插入元素 tmp</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(insert_sort(nums))</span><br></pre></td></tr></table></figure>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>选择排序是选择无序序列中的最小的元素放到有序序列的末尾，直到无序序列没有元素。</p>
<p><img src="/images/选择排序.png" alt="插入排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):  <span class="comment"># 遍历无序数组的每一个元素</span></span><br><span class="line">        <span class="comment"># i和nums[i]</span></span><br><span class="line">        min_val = nums[i] </span><br><span class="line">        min_j = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums)):  <span class="comment"># 寻找剩余待排数组的最小元素</span></span><br><span class="line">            <span class="keyword">if</span> min_val &gt; nums[j]:</span><br><span class="line">                min_val = nums[j]</span><br><span class="line">                min_j = j</span><br><span class="line">        nums[i], nums[min_j] = nums[min_j], nums[i]  <span class="comment"># 交换最小元素和</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(selection_sort(nums))</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">希尔排序是对插入排序的优化。</span><br><span class="line">希尔排序，通过将原始序列按照一定的步长划分为多个子序列</span><br><span class="line">	将原始的一维数组映射成二维数组，</span><br><span class="line">	然后按列进行插入排序，</span><br><span class="line">这样的话，可以让一个元素在一次比较中跨越较大的区间，随后算法在使用较小的步长，一直到步长为1</span><br><span class="line">(已知当对有序度较高数组进行排序时，插入排序的时间复杂度接近O(N)，因此可以大幅度提高插入排序的效率)。</span><br></pre></td></tr></table></figure>
<p><img src="/images/希尔排序.png" alt="希尔排序"></p>
<blockquote>
<p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F</a></p>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(list)</span>:</span></span><br><span class="line">    n = len(list)</span><br><span class="line">    <span class="comment"># 初始步长</span></span><br><span class="line">    gap = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        print(gap)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            <span class="comment"># 每个步长进行插入排序</span></span><br><span class="line">            temp = list[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> list[j - gap] &gt; temp:</span><br><span class="line">                list[j] = list[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">                print(<span class="string">'inner='</span>, list)</span><br><span class="line">            list[j] = temp</span><br><span class="line">        print(list)</span><br><span class="line">        <span class="comment"># 得到新的步长</span></span><br><span class="line">        gap = gap // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort1</span><span class="params">(collection)</span>:</span></span><br><span class="line">    <span class="comment"># Marcin Ciura's gap sequence</span></span><br><span class="line">    gaps = [<span class="number">701</span>, <span class="number">301</span>, <span class="number">132</span>, <span class="number">57</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> gap <span class="keyword">in</span> gaps:</span><br><span class="line">        i = gap</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(collection):</span><br><span class="line">            temp = collection[i]</span><br><span class="line">            j = i</span><br><span class="line">            <span class="keyword">while</span> j &gt;= gap <span class="keyword">and</span> collection[j - gap] &gt; temp:</span><br><span class="line">                collection[j] = collection[j - gap]</span><br><span class="line">                j -= gap</span><br><span class="line">            collection[j] = temp</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> collection</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(<span class="string">'\n'</span>, shell_sort1(nums))</span><br></pre></td></tr></table></figure>
<h3 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O($nlogn$)"></a>O($nlogn$)</h3><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>将数组分为两部分，分别排序，最后将两部分排好序的数组合并成一个有序的数组。利用递归的方式，重复上述过程。</p>
<p>归并排序为什么会高效：<strong><code>合并两个有序数组的时间复杂度是O(N)的</code></strong>，将一个完整的数组递归的一分为二，那么分解到数组中只有一个元素时，分解的次数为logn，故整体的时间复杂度为O(nlogn)。</p>
<p><img src="/images/归并排序.png" alt="归并排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    print(<span class="string">'before='</span>, nums)</span><br><span class="line">    length = len(nums)</span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">1</span>:</span><br><span class="line">        midpoint = length // <span class="number">2</span></span><br><span class="line">        left_half = merge_sort(nums[:midpoint])</span><br><span class="line">        right_half = merge_sort(nums[midpoint:])</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        left_length = len(left_half)</span><br><span class="line">        right_length = len(right_half)</span><br><span class="line">        <span class="keyword">while</span> i &lt; left_length <span class="keyword">and</span> j &lt; right_length:</span><br><span class="line">            <span class="keyword">if</span> left_half[i] &lt; right_half[j]:</span><br><span class="line">                nums[k] = left_half[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums[k] = right_half[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; left_length:</span><br><span class="line">            nums[k] = left_half[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &lt; right_length:</span><br><span class="line">            nums[k] = right_half[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'after='</span>, nums)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">    print(<span class="string">'\n'</span>, merge_sort(nums))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment"># 二分</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 排列左半部分</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 排列右半部分</span></span><br><span class="line">    merge(nums, left, mid, right)  <span class="comment"># 合并左右两个已经有序的数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, left, mid, right)</span>:</span></span><br><span class="line">    tmp = [<span class="number">0</span>] * (right - left + <span class="number">1</span>)</span><br><span class="line">    i, j, k = left, mid + <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j]: tmp[k], i = nums[i], i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: tmp[k], j = nums[j], j + <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid: tmp[k], k, i = nums[i], k + <span class="number">1</span>, i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= right: tmp[k], k, j = nums[j], k + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">    nums[left:right+<span class="number">1</span>] = tmp[:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">-23</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">merge_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(nums, left, right)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right: <span class="keyword">return</span></span><br><span class="line">    mid = (left + right) &gt;&gt; <span class="number">1</span>  <span class="comment"># 二分</span></span><br><span class="line">    merge_sort(nums, left, mid)  <span class="comment"># 排列左半部分</span></span><br><span class="line">    merge_sort(nums, mid + <span class="number">1</span>, right)  <span class="comment"># 排列右半部分</span></span><br><span class="line">    merge(nums, left, mid, right)  <span class="comment"># 合并左右两个已经有序的数组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(nums, left, mid, right)</span>:</span></span><br><span class="line">    tmp = []</span><br><span class="line">    i, j = left, mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= right:</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; nums[j]:</span><br><span class="line">            tmp.append(nums[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tmp.append(nums[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    tmp.extend(nums[i:mid + <span class="number">1</span>] <span class="keyword">if</span> i &lt;= mid <span class="keyword">else</span> nums[j:right + <span class="number">1</span>])</span><br><span class="line">    nums[left:right + <span class="number">1</span>] = tmp[:]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">-23</span>, <span class="number">88</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">99</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">-4</span>, <span class="number">34</span>, <span class="number">2</span>]</span><br><span class="line">merge_sort(nums, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>; <span class="comment">// (left + right) / 2</span></span><br><span class="line"></span><br><span class="line">    mergeSort(array, left, mid);</span><br><span class="line">    mergeSort(array, mid + <span class="number">1</span>, right);</span><br><span class="line">    merge(array, left, mid, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)   temp[k++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right) temp[k++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; temp.length; p++) &#123;</span><br><span class="line">        arr[left + p] = temp[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 也可以用 System.arraycopy(a, start1, b, start2, length)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">// 中间数组</span></span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">        temp[k++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i&lt;=mid) System.arraycopy(arr, i, temp, k, mid-i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (j&lt;=right) System.arraycopy(arr, j, temp, k, right-j+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	System.arraycopy(temp, <span class="number">0</span>, arr, left, temp.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>随机选择一个pivot节点，然后将数组中的数据分成大于pivot和小于pivot的两部分，然后递归地将大于pivot和小于pivot的部分再按照相同的思路处理，直到每个pivot两端的部分都只有最多一个元素</p>
<p><img src="/images/快排.png" alt="快排"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(collection)</span>:</span></span><br><span class="line">    length = len(collection)</span><br><span class="line">    <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> collection</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        pivot = collection[<span class="number">0</span>]</span><br><span class="line">        greater = [element <span class="keyword">for</span> element <span class="keyword">in</span> collection[<span class="number">1</span>:] <span class="keyword">if</span> element &gt; pivot]</span><br><span class="line">        lesser = [element <span class="keyword">for</span> element <span class="keyword">in</span> collection[<span class="number">1</span>:] <span class="keyword">if</span> element &lt;= pivot]</span><br><span class="line">        <span class="keyword">return</span> quick_sort(lesser) + [pivot] + quick_sort(greater)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>O(n) 时间复杂度内求无序数组中的第 K 大元素</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择数组的最后一个元素，作为pivot，然后将数组的所有元素分为大于pivot和小于pivot的两部分，</span></span><br><span class="line"><span class="comment"># 如果 len(lesser) == k - 1，则返回pivot</span></span><br><span class="line"><span class="comment"># 如果 len(lesser) &gt;= k，则说明要查找的元素在小于pivot的部分，那么继续在lesser中查找</span></span><br><span class="line"><span class="comment"># 否则的话，说明要查找的元素在大于pivot的部分，那么继续在greater中查找</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_k_max</span><span class="params">(nums, k)</span>:</span></span><br><span class="line">    length = len(nums)</span><br><span class="line">    <span class="keyword">if</span> length &lt; k:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    pivot = nums[length - <span class="number">1</span>]</span><br><span class="line">    greater = [element <span class="keyword">for</span> element <span class="keyword">in</span> nums[:length - <span class="number">1</span>] <span class="keyword">if</span> element &gt; pivot]</span><br><span class="line">    lesser = [element <span class="keyword">for</span> element <span class="keyword">in</span> nums[:length - <span class="number">1</span>] <span class="keyword">if</span> element &lt;= pivot]</span><br><span class="line">    <span class="keyword">if</span> len(lesser) == k - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> pivot</span><br><span class="line">    <span class="keyword">elif</span> len(lesser) &gt;= k:</span><br><span class="line">        <span class="keyword">return</span> find_k_max(lesser, k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> find_k_max(greater, k - len(lesser) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>In-place算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(nums, begin, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> begin&gt;=end: <span class="keyword">return</span></span><br><span class="line">    pivot = partition(nums, begin, end)  <span class="comment"># 找到[begin,end]的pivot点，pivot点已经固定了，是不需要对它进行排序的</span></span><br><span class="line">    quick_sort(nums, begin, pivot<span class="number">-1</span>)  <span class="comment"># 递归调用nums[begin, pivot-1]</span></span><br><span class="line">    quick_sort(nums, pivot+<span class="number">1</span>, end)  <span class="comment"># 递归调用nums[pivot+1, end]</span></span><br><span class="line">   	<span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(nums, begin, end)</span>:</span></span><br><span class="line">    <span class="comment"># pivot是作为对比的值</span></span><br><span class="line">    <span class="comment"># last_smaller是指向小于pivot的子数组的下一个位置的指针   类似于leetcode [移动零] 那一题的解法</span></span><br><span class="line">    pivot, last_smaller = end, begin</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(begin, end): <span class="comment"># 从前往后遍历待排数组</span></span><br><span class="line">        <span class="keyword">if</span> nums[i]&lt;nums[pivot]: <span class="comment"># 如果当前元素小于pivot，那么调换当前元素和last_smaller位置的元素</span></span><br><span class="line">            nums[i], nums[last_smaller] = nums[last_smaller], nums[i]</span><br><span class="line">            last_smaller+=<span class="number">1</span>  <span class="comment"># last_smaller 向后移动一位</span></span><br><span class="line">    <span class="comment"># 把pivot的值移动到last_smaller位置</span></span><br><span class="line">    nums[last_smaller], nums[pivot] = nums[pivot], nums[last_smaller]</span><br><span class="line">    <span class="keyword">return</span> last_smaller</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">nums = []</span><br><span class="line">quick_sort(nums, <span class="number">0</span>, len(nums)<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt;= begin) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = partition(array, begin, end);</span><br><span class="line">    quickSort(array, begin, pivot - <span class="number">1</span>);</span><br><span class="line">    quickSort(array, pivot + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// pivot: 标杆位置</span></span><br><span class="line">    <span class="comment">// last_smaller是指向小于pivot的子数组的下一个位置的指针   类似于leetcode [移动零] 那一题的解法</span></span><br><span class="line">    <span class="keyword">int</span> pivot = end, last_smaller = begin;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = begin; i &lt; end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[pivot]) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = a[last_smaller]; a[last_smaller] = a[i]; a[i] = temp;</span><br><span class="line">            last_smaller++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> temp = a[pivot]; a[pivot] = a[last_smaller]; a[last_smaller] = temp;</span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>使用大顶堆和小顶堆的数据结构，进行排序：大顶堆，每次取堆顶元素，遍历完则得到从大到小的序列；小顶堆则相反。</p>
<p>堆有很多种实现，这里只看二叉堆。二叉堆是一种近似完全二叉树，所以可以使用数组存储，每个父亲节点都要比其孩子节点大(大顶堆，小顶堆相反)</p>
<p>利用堆进行排序，包含两个步骤：第一、将数据放入堆中以满足堆的条件；第二、将数据从堆中取出。即为有序数组</p>
<p><img src="/images/堆排序.png" alt="堆排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Python</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapify</span><span class="params">(parent_index, length, nums)</span>:</span></span><br><span class="line">    temp = nums[parent_index]</span><br><span class="line">    child_index = <span class="number">2</span>*parent_index+<span class="number">1</span> <span class="comment"># 取到左孩子</span></span><br><span class="line">    <span class="keyword">while</span> child_index &lt; length: </span><br><span class="line">        <span class="comment"># 先检查右孩子，看右孩子是不是比左孩子大，是的话更新孩子节点索引到 右孩子</span></span><br><span class="line">        <span class="keyword">if</span> child_index+<span class="number">1</span> &lt; length <span class="keyword">and</span> nums[child_index+<span class="number">1</span>] &gt; nums[child_index]:</span><br><span class="line">            child_index = child_index+<span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果父结点大于孩子节点，那么停止循环</span></span><br><span class="line">        <span class="keyword">if</span> temp &gt; nums[child_index]:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 将父结点更新到新检查的孩子节点，重复上面的操作</span></span><br><span class="line">        nums[parent_index] = nums[child_index]</span><br><span class="line">        parent_index = child_index</span><br><span class="line">        child_index = <span class="number">2</span>*parent_index + <span class="number">1</span></span><br><span class="line">    nums[parent_index] = temp  <span class="comment"># 最后，把父结点元素归位</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heapsort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    <span class="comment">## start from (len(nums)-2)//2:看一下图就知道了</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range((len(nums)<span class="number">-2</span>)//<span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        heapify(i, len(nums), nums)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        nums[j], nums[<span class="number">0</span>] = nums[<span class="number">0</span>], nums[j]</span><br><span class="line">        heapify(<span class="number">0</span>, j, nums)</span><br></pre></td></tr></table></figure>
<p><img src="/images/二叉堆.png" alt="image-20200614085943287"></p>
<p>当len=12，那么从数组下标为5开始调整，图中的6位置</p>
<p>当len=11，那么从数组下标为4开始调整，图中的5位置</p>
<p>依次类推</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> length, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span>；</span><br><span class="line">    <span class="keyword">int</span> largest = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &lt; length &amp;&amp; array[left] &gt; array[largest]) &#123;</span><br><span class="line">        largest = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; length &amp;&amp; array[right] &gt; array[largest]) &#123;</span><br><span class="line">        largest = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i]; array[i] = array[largest]; array[largest] = temp;</span><br><span class="line">        heapify(array, length, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> length = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length / <span class="number">2</span>-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        heapify(array, length, i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[<span class="number">0</span>]; array[<span class="number">0</span>] = array[i]; array[i] = temp;</span><br><span class="line">        heapify(array, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中的第K个最大元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> heapSize = nums.length;</span><br><span class="line">        buildMaxHeap(nums, heapSize);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= nums.length - k + <span class="number">1</span>; --i) &#123;</span><br><span class="line">            swap(nums, <span class="number">0</span>, i);</span><br><span class="line">            --heapSize;</span><br><span class="line">            maxHeapify(nums, <span class="number">0</span>, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = heapSize / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            maxHeapify(a, i, heapSize);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maxHeapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>, largest = i;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; heapSize &amp;&amp; a[l] &gt; a[largest]) &#123;</span><br><span class="line">            largest = l;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (r &lt; heapSize &amp;&amp; a[r] &gt; a[largest]) &#123;</span><br><span class="line">            largest = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(a, i, largest);</span><br><span class="line">            maxHeapify(a, largest, heapSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O($n$)"></a>O($n$)</h3><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p>
<p>步骤</p>
<ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<p>使用的局限性：</p>
<ol>
<li><p>待排序的数组元素只能为有确定范围的整数，因为要使用数组的索引来标识元素的顺序</p>
<p>有时候，小数和负数，可以通过乘以一个倍数或者加上一个正数，来调整成可以使用计数排序的形式</p>
</li>
<li><p>待排序数组的范围不能太大，否则会占用大量的内存，如果数据倾斜严重，可能只会使用到一小部分的位置，会造成大量的内存白白消耗</p>
</li>
</ol>
<p>升级：</p>
<p>可以使用下面要讲的桶排序，来弥补计数排序的两点不足</p>
<p><img src="/images/计数排序.png" alt="计数排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">max_value = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(nums)</span>:</span></span><br><span class="line">    bucket = [<span class="number">0</span>] * max_value</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        bucket[num] += <span class="number">1</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max_value):</span><br><span class="line">        nums[j:j + bucket[i]] = ([i] * bucket[i])[:]</span><br><span class="line">        j += bucket[i]</span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">9</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">56</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">78</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">8</span>]</span><br><span class="line">count_sort(nums)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p>
<p>步骤</p>
<ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li>
</ul>
<p><img src="/images/基数排序.png" alt="849589-20171015232453668-1397662527"></p>
<p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要O(n)的时间复杂度。假如待排数据可以分为d个关键字，则基数排序的时间复杂度将是O(d*2n) ，当然d要远远小于n，因此基本上还是线性级别的。</p>
<p>基数排序的空间复杂度为O(n+k)，其中k为桶的数量。一般来说n&gt;&gt;k，因此额外空间需要大概n个左右。</p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(nums, max_digit)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    max_digit 表示最大的位数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 十进制数每位只能有10个选择：0-9</span></span><br><span class="line">    <span class="keyword">for</span> digit <span class="keyword">in</span> range(max_digit):  <span class="comment"># 从低位开始分桶</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 对每个数整除10的倍数 取余，填入对一个的坑位</span></span><br><span class="line">            bucket[(num // (<span class="number">10</span> ** digit)) % <span class="number">10</span>].append(num)</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):  <span class="comment"># 遍历10个坑位，把数据回填入nums</span></span><br><span class="line">            nums[j:j + len(bucket[i])] = bucket[i][:]</span><br><span class="line">            j += len(bucket[i])</span><br><span class="line"></span><br><span class="line">        bucket = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]  <span class="comment"># 一轮结束后，清空原来的bucket</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = radix_sort([<span class="number">32</span>, <span class="number">43</span>, <span class="number">4</span>, <span class="number">54</span>, <span class="number">24</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">13</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">134</span>, <span class="number">4</span>, <span class="number">53</span>, <span class="number">34</span>, <span class="number">1</span>, <span class="number">34</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, ], <span class="number">3</span>)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><blockquote>
<p>算法描述</p>
</blockquote>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p>
<p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大</p>
<p><img src="/images/桶排序.png" alt="桶排序"></p>
<blockquote>
<p>算法实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> TheAlgorithms.sorts.insert_sort <span class="keyword">import</span> insert_sort1</span><br><span class="line"></span><br><span class="line">DEFAULT_BUCKET_SIZE = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(my_list, bucket_size=DEFAULT_BUCKET_SIZE)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(my_list) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'You don\'t have any elements in array!'</span>)</span><br><span class="line"></span><br><span class="line">    minValue = my_list[<span class="number">0</span>]</span><br><span class="line">    maxValue = my_list[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For finding minimum and maximum values</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(my_list)):</span><br><span class="line">        <span class="keyword">if</span> my_list[i] &lt; minValue:</span><br><span class="line">            minValue = my_list[i]</span><br><span class="line">        <span class="keyword">elif</span> my_list[i] &gt; maxValue:</span><br><span class="line">            maxValue = my_list[i]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Initialize buckets</span></span><br><span class="line">    bucketCount = math.floor((maxValue - minValue) / bucket_size) + <span class="number">1</span></span><br><span class="line">    buckets = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, bucketCount):</span><br><span class="line">        buckets.append([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># For putting values in buckets</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(my_list)):</span><br><span class="line">        buckets[math.floor((my_list[i] - minValue) / bucket_size)].append(my_list[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Sort buckets and place back into input array</span></span><br><span class="line">    sorted_array = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(buckets)):</span><br><span class="line">        insert_sort1(buckets[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(buckets[i])):</span><br><span class="line">            sorted_array.append(buckets[i][j])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sorted_array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    sorted_array = bucket_sort([<span class="number">12</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">81</span>, <span class="number">56</span>, <span class="number">95</span>])</span><br><span class="line">    print(sorted_array)</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/ws-site/tags/排序算法/" rel="tag"># 排序算法</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ws-site/post/数据分析-reduce函数引发的/" rel="prev" title="数据分析-reduce函数引发的">
      <i class="fa fa-chevron-left"></i> 数据分析-reduce函数引发的
    </a></div>
      <div class="post-nav-item">
    <a href="/ws-site/post/Spark学习笔记-DSL语法/" rel="next" title="Spark学习笔记-DSL语法">
      Spark学习笔记-DSL语法 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#算法分类"><span class="nav-number">1.</span> <span class="nav-text">算法分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#算法复杂度"><span class="nav-number">2.</span> <span class="nav-text">算法复杂度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#相关概念"><span class="nav-number">3.</span> <span class="nav-text">相关概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#O-n-2"><span class="nav-number">4.</span> <span class="nav-text">O($n^2$)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#冒泡排序-Bubble-Sort"><span class="nav-number">4.1.</span> <span class="nav-text">冒泡排序(Bubble Sort)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#插入排序"><span class="nav-number">4.2.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#选择排序"><span class="nav-number">4.3.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希尔排序"><span class="nav-number">4.4.</span> <span class="nav-text">希尔排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#O-nlogn"><span class="nav-number">5.</span> <span class="nav-text">O($nlogn$)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序"><span class="nav-number">5.1.</span> <span class="nav-text">归并排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#快速排序"><span class="nav-number">5.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆排序"><span class="nav-number">5.3.</span> <span class="nav-text">堆排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#O-n"><span class="nav-number">6.</span> <span class="nav-text">O($n$)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计数排序"><span class="nav-number">6.1.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基数排序"><span class="nav-number">6.2.</span> <span class="nav-text">基数排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#桶排序"><span class="nav-number">6.3.</span> <span class="nav-text">桶排序</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">王尚</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/ws-site/archives/">
        
          <span class="site-state-item-count">195</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/ws-site/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/ws-site/tags/">
          
        <span class="site-state-item-count">148</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王尚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/ws-site/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/ws-site/lib/velocity/velocity.min.js"></script>
  <script src="/ws-site/lib/velocity/velocity.ui.min.js"></script>
<script src="/ws-site/js/utils.js"></script><script src="/ws-site/js/motion.js"></script>
<script src="/ws-site/js/schemes/muse.js"></script>
<script src="/ws-site/js/next-boot.js"></script>

  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>