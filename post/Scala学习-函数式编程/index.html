<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ws2823147532.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简介：">
<meta name="keywords" content="函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala学习-函数式编程">
<meta property="og:url" content="https://ws2823147532.github.io/ws-site/post/Scala学习-函数式编程/index.html">
<meta property="og:site_name" content="努力，奋斗">
<meta property="og:description" content="简介：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=f%28x_%7Ba%7D%29%3Dy">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=f%28x_%7Bb%7D%29%3Dz">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=y%3Dz">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Clambda+x.x%2B2">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Clambda+f.f+3">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+f.f+3+%5Cright%29%5Cleft%28+%5Clambda+x.x%2B2+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+f.f+3+%5Cright%29%5Cleft%28+%5Clambda+x.x%2B2+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x%2B2+%5Cright%29+3">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=3%2B2">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=f%5Cleft%28+x%2Cy+%5Cright%29+%3Dx-y">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Clambda+x.%5Clambda+y.x-y">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.%5Clambda+y.x-y+%5Cright%29+7+2">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+y.7-y+%5Cright%29+2">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=7-2">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=0%3D%5Clambda+f.%5Clambda+x.x">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=1%3D%5Clambda+f.%5Clambda+x.f+x">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=2%3D%5Clambda+f.%5Clambda+x.f+%5Cleft%28+f+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=3%3D%5Clambda+f.%5Clambda+x.f+x%5Cleft%28+f+%5Cleft%28+f+x+%5Cright%29+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=SUCC%3D%5Clambda+n.%5Clambda+f.%5Clambda+x.f%5Cleft%28+n+f+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=PLUS%3D%5Clambda+m.%5Clambda+n.%5Clambda+f.%5Clambda+x.m+f%5Cleft%28+n+f+x+%5Cright%29+">
<meta property="og:image" content="https://www.zhihu.com/equation?tex=MULT%3D%5Clambda+m.%5Clambda+f.%5Clambda+n.m+%5Cleft%28+n+f+%5Cright%29+">
<meta property="og:updated_time" content="2021-04-19T03:41:23.136Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Scala学习-函数式编程">
<meta name="twitter:description" content="简介：">
<meta name="twitter:image" content="https://www.zhihu.com/equation?tex=f%28x_%7Ba%7D%29%3Dy">

<link rel="canonical" href="https://ws2823147532.github.io/ws-site/post/Scala学习-函数式编程/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Scala学习-函数式编程 | 努力，奋斗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">努力，奋斗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Scala学习-函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Scala学习-函数式编程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-29 16:51:56" itemprop="dateCreated datePublished" datetime="2020-07-29T16:51:56+08:00">2020-07-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-19 11:41:23" itemprop="dateModified" datetime="2021-04-19T11:41:23+08:00">2021-04-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Scala学习/" itemprop="url" rel="index"><span itemprop="name">Scala学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>简介：</p>
</blockquote>
<a id="more"></a>
<h1 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h1><p>函数的职责是单一的   ——— 这和面向接口的编程模型是一致的</p>
<p>纯函数：没有副作用的函数</p>
<p>什么是副作用：从输入到输出的过程中还干了一些额外的事情</p>
<p>​    修改了某些值、与外部系统发生交互、直接修改数据结构</p>
<p>函数式编程的好处：</p>
<p>功能模块化、易测试、易复用、并行化、泛化、推导</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>函数式编程又称泛函编程是一种编程范型，它将计算机运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。λ演算中最关键的要素就是函数被当作变量处理，能够参与运算。与之对应的，命令式编程是一种描述电脑所需作出的行为的编程范型。比起命令式编程，函数式编程更加强调执行的结果而非执行过程，倡导利用若干简单的执行单元让计算结果不断演进，抽丝剥茧逐层推导复杂的运算，而不是设计一个复杂的运算过程。总结一下就是</p>
<h2 id="命令式编程-Imperative"><a href="#命令式编程-Imperative" class="headerlink" title="命令式编程(Imperative)"></a>命令式编程(Imperative)</h2><p>命令“机器”如何去做事情(how)，这样不管你想要的是什么(what)，它都会按照你的命令实现。</p>
<h2 id="函数式编程-functional"><a href="#函数式编程-functional" class="headerlink" title="函数式编程(functional)"></a>函数式编程(functional)</h2><p>告诉“机器”你想要的是什么(what)，让机器想出如何去做(how)。</p>
<p>我们用一个使数组翻倍的例子来比较这两种编程范式。</p>
<p>Java Code \ Imperative</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Integer n : nums) &#123;</span><br><span class="line">    n*=<span class="number">2</span>;</span><br><span class="line">    nums[i++]=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历整个数组，取出每个元素，乘以二，然后把翻倍后的值放回数组，每次都要操作这个数组，直到计算完所有元素。</p>
<p>Scala code \ functional</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nums = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> doubleNums = nums.map(_*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>利用Array的map函数，将所有元素<em>2，并生成了一个新的双倍数组。map函数所做的事情是把遍历整个数组的过程，归纳并抽离出来，让我们专注于描述我们想要的是什么”**</em>_*2***”。我们传入map的是一个纯函数；它不具有任何副作用(不会改变外部状态)，它只是接收一个数字，返回乘以2后的值。PS： <code>_</code> 字符是scala中的入参缩写形式。</p>
<p>正如<strong>封装、继承</strong>和<strong>多态</strong>是面向对象编程的三大特性。函数式编程也有自己的语言特性：<strong>数据不可变、函数是第一公民、引用透明</strong>和<strong>尾递归</strong></p>
<p><strong>*数据不可变（immutable data）</strong>：变量只赋值一次，如果想改变其值就创建一个新的。</p>
<p><strong>*函数是第一公民（first class method）</strong>函数可以像普通变量一样去使用。函数可以像变量一样被创建，修改，并当成变量一样传递，返回或是在函数中嵌套函数。</p>
<p><strong>*引用透明(referential transparency)</strong> 指的是函数的运行不依赖于外部变量或“状态”，只依赖于输入的参数，任何时候只要参数相同，调用函数所得到的返回值总是相同的。天然适应并发编程，因为调用函数的结果具有一致性，所以根本不需要加锁，也就不存在死锁的问题。</p>
<p><strong>*尾递归（tail call optimization）</strong>:函数调用要压栈保存现场，递归层次过深的话，压栈过多会产生性能问题。所以引入尾递归优化，每次递归时都会重用栈，提升性能。</p>
<p>-—————————————————————————————————————————————————————————————</p>
<h3 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; y) x <span class="keyword">else</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>def</strong> 是声明函数的关键字，小括号中的<em>x:Int,y:int</em>是函数的入参，紧跟着的<strong>:Int</strong>是函数返回值类型，花括号中的是函数体。(前一章介绍过，如果函数返回类型是非<strong>Unit</strong>，那么默认代码执行的最后一行的值，即为返回值，不需要显式的注明<strong>return</strong>关键字)</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> increment = (x: <span class="type">Int</span>) =&gt; x + <span class="number">1</span></span><br><span class="line">increment(<span class="number">2</span>)</span><br><span class="line"><span class="comment">// output 3</span></span><br></pre></td></tr></table></figure>
<p>匿名函数是指一类无需定义标识符的函数，定义匿名函数的语法很简单，<strong>=&gt;</strong>箭头左边是参数列表，右边是函数体。可以把命名函数赋值给一个变量使用。</p>
<p>另一种方式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> increment =<span class="keyword">new</span> <span class="type">Function1</span>[<span class="type">Int</span>, <span class="type">Int</span>] &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(x: <span class="type">Int</span>): <span class="type">Int</span> = x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="无参匿名函数"><a href="#无参匿名函数" class="headerlink" title="无参匿名函数"></a>无参匿名函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sayHello = () =&gt; &#123; <span class="type">System</span>.out.print(<span class="string">"Hello World!"</span>) &#125;</span><br><span class="line">sayHello()</span><br><span class="line"><span class="comment">//output: Hello World!</span></span><br></pre></td></tr></table></figure>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>至少满足以下条件之一的函数，即为高阶函数</p>
<ol>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ol>
<p>在数学领域他们也叫做算子或泛函。微积分中的导数就是常见的例子，它映射一个函数到另一个函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> convert2String=(x:<span class="type">Int</span>)=&gt;<span class="string">"==["</span> + x.toString() + <span class="string">"]=="</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(f: <span class="type">Int</span> =&gt; <span class="type">String</span>, v: <span class="type">Int</span>) = f(v)</span><br><span class="line">apply(convert2String,<span class="number">36</span>)</span><br><span class="line"><span class="comment">//output: ==[36]==</span></span><br></pre></td></tr></table></figure>
<h3 id="嵌入式函数-本地函数"><a href="#嵌入式函数-本地函数" class="headerlink" title="嵌入式函数(本地函数)"></a>嵌入式函数(本地函数)</h3><p>在Scala中可以在函数体中再定义一个函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(xs: <span class="type">List</span>[<span class="type">Int</span>], threshold: <span class="type">Int</span>) = &#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(ys: <span class="type">List</span>[<span class="type">Int</span>]): <span class="type">List</span>[<span class="type">Int</span>] =</span><br><span class="line"><span class="keyword">if</span> (ys.isEmpty) ys</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ys.head &lt; threshold) ys.head :: process(ys.tail)</span><br><span class="line"><span class="keyword">else</span> process(ys.tail)</span><br><span class="line">  process(xs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数柯里化-Currying"><a href="#函数柯里化-Currying" class="headerlink" title="函数柯里化(Currying)"></a>函数柯里化(Currying)</h3><p>在计算机科学中，柯里化是指把接受多个参数的函数变换成接受一个单一参数的函数，并且返回其余的参数和结果的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">curriedSum</span></span>(x: <span class="type">Int</span>)(y: <span class="type">Int</span>)(z: <span class="type">Int</span>) = x + y + z</span><br><span class="line"><span class="keyword">val</span> sum = curriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//output: 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//the calling procedure of currying function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(x: <span class="type">Int</span>) = (y: <span class="type">Int</span>) =&gt; (z: <span class="type">Int</span>) =&gt; x + y + z</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">second</span> </span>= first(<span class="number">5</span>)</span><br><span class="line"><span class="comment">//output: Int =&gt; (Int =&gt; Int) = 5 + y + z</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">third</span> </span>= second(<span class="number">6</span>)</span><br><span class="line"><span class="comment">//output: Int =&gt; Int = 5 + 6 + z</span></span><br><span class="line"><span class="keyword">val</span> fourth = third(<span class="number">7</span>)</span><br><span class="line"><span class="comment">//output: 18</span></span><br><span class="line"></span><br><span class="line">first(<span class="number">5</span>)(<span class="number">6</span>)(<span class="number">7</span>)</span><br><span class="line"><span class="comment">//output: 18</span></span><br></pre></td></tr></table></figure>
<p>代码范例中，curriedSum是一个currying函数的Scala写法，而first、second、third、fourth展示了currying函数调用过程。通过代码注释可看到second、third返回的都是函数，直到fourth才返回求和值。而这种特性也正是惰性求值的秘密所在。</p>
<h3 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h3><p>假如有一个函数可以表示很多的含义，比如有一个函数<code>fun(m,n)</code>求$m^n$，我们更常用的可能是求$m^2$或者$m^3$，那么我们就可以固定次数为2或3，来创建一个新的函数，如<code>fun2=fun(m, 2)</code>和<code>fun3=fun(m,3)</code>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>, z: <span class="type">Int</span>) = &#123;</span><br><span class="line">x + y + z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> sum2 = sum(<span class="number">10</span>, _: <span class="type">Int</span>, <span class="number">15</span>)</span><br><span class="line">sum2(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//output: 27</span></span><br></pre></td></tr></table></figure>
<h3 id="偏函数-Partial-Function"><a href="#偏函数-Partial-Function" class="headerlink" title="偏函数(Partial Function)"></a>偏函数(Partial Function)</h3><p>Scala定义了一个特殊的<strong>偏函数(Partial Function)</strong>。首先，我先来理解偏函数的概念。</p>
<p>从输入集合X到可能的输出集合Y的函数f(记作f(X)=&gt;Y)是X与Y的关系，满足如下条件：</p>
<ol>
<li><strong>f是完全的</strong>即对于集合X中的任一元素x都有集合Y中的元素y，从而满足f(x)=y,换句话说就是每一个输入值x都有y与之对应。</li>
<li><strong>f是多对一的</strong>即存在 <img src="https://www.zhihu.com/equation?tex=f%28x_%7Ba%7D%29%3Dy" alt="[公式]"> 且 <img src="https://www.zhihu.com/equation?tex=f%28x_%7Bb%7D%29%3Dz" alt="[公式]"> 并且 <img src="https://www.zhihu.com/equation?tex=y%3Dz" alt="[公式]"> 。也就是多个输入可以映射一个输出，但一个输入不能映射多个输出。</li>
</ol>
<p>那么结论来了，X与Y的关系f满足条件1，则为<strong>多值函数</strong>。X与Y的关系f满足条件2，则为<strong>偏函数</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> pf: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"One"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"Two"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">"Three"</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span> =&gt; <span class="string">"Nine"</span></span><br><span class="line">  <span class="keyword">case</span> _=&gt; <span class="string">"Nothing"</span></span><br><span class="line">&#125;</span><br><span class="line">pf(<span class="number">1</span>) <span class="comment">// output: One</span></span><br><span class="line">pf(<span class="number">2</span>) <span class="comment">// output: Two</span></span><br><span class="line">pf(<span class="number">5</span>) <span class="comment">// output: Nothing</span></span><br><span class="line">pf(<span class="number">9</span>) <span class="comment">// output: Nine</span></span><br></pre></td></tr></table></figure>
<p>示例代码中，我们定义了一个Scala的偏函数，那么只有1、2、3、9有对应的输出值，而输入其它值只会打印 Nothing。</p>
<p>那么偏函数有什么应用价值呢？函数式的编程思想是以一种“演绎法”而非“归纳法”去寻求解决空间。也就是说，它并不是要去归纳问题然后分解问题并解决问题，而是看请问题本质，定义最初的想法和组合规则，面对问题时，可以通过组合各种函数去解决问题，这也正是“组合子（combinator）”的含义。偏函数则更进一步，将函数求解空间中各个分支也分离出来，形成可以被组合的偏函数。</p>
<p>e.g. 偏函数使用orElse组成新的函数，得到的偏函数反映了是否对给定参数进行了定义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> one: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> =&gt; <span class="string">"one"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> two: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span> =&gt; <span class="string">"two"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> three: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span> =&gt; <span class="string">"three"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> wildcard: <span class="type">PartialFunction</span>[<span class="type">Int</span>, <span class="type">String</span>] = &#123;</span><br><span class="line"><span class="keyword">case</span> _ =&gt; <span class="string">"something else"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> partial = one orElse two orElse three orElse wildcard</span><br><span class="line"></span><br><span class="line">partial(<span class="number">5</span>)</span><br><span class="line"><span class="comment">//output: something else</span></span><br><span class="line">partial(<span class="number">3</span>)</span><br><span class="line"><span class="comment">//output: three</span></span><br><span class="line">partial(<span class="number">2</span>)</span><br><span class="line"><span class="comment">//output:  two</span></span><br><span class="line">partial(<span class="number">1</span>)</span><br><span class="line"><span class="comment">//output:  = one</span></span><br><span class="line">partial(<span class="number">0</span>)</span><br><span class="line"><span class="comment">//output:  something else</span></span><br></pre></td></tr></table></figure>
<p>此外，在集合类的很多函数都带有这种偏函数的能力。e.g. map 函数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="type">L1</span> = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"A"</span>, <span class="number">4</span>, <span class="string">"B"</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">L2</span> = <span class="type">L1</span> map &#123; </span><br><span class="line"><span class="keyword">case</span> x: <span class="type">Int</span> =&gt; x * x</span><br><span class="line"><span class="keyword">case</span> x: <span class="type">String</span> =&gt; <span class="string">s"<span class="subst">$x</span>*<span class="subst">$x</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//L2: List[Any] = List(1, 4, 9, A*A, 16, B*B, 25)</span></span><br></pre></td></tr></table></figure>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>又称函数闭包，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，换句话说，闭包是由函数和与其相关的引用环境组合成的。</p>
<p>PS:另外一种解释，对象是带有函数的数据，<strong>闭包是带有数据的函数</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> more = <span class="number">2</span></span><br><span class="line"><span class="keyword">val</span> addMore = (x: <span class="type">Int</span>) =&gt;  x + more</span><br><span class="line">addMore(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="传值调用函数-call-by-value"><a href="#传值调用函数-call-by-value" class="headerlink" title="传值调用函数(call by value)"></a>传值调用函数(call by value)</h3><p>先计算参数表达式的值，再应用到函数内部即为传值调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assert</span></span>(predicate: () =&gt; <span class="type">Boolean</span>) =</span><br><span class="line"><span class="keyword">if</span> (!predicate())</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span></span><br><span class="line"></span><br><span class="line">assert(() =&gt; (<span class="number">1</span> &gt; <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="传名调用函数-call-by-name"><a href="#传名调用函数-call-by-name" class="headerlink" title="传名调用函数(call by name)"></a>传名调用函数(call by name)</h3><p>将未计算的参数表达式直接应用到函数内部即为传名调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">assert</span></span>(predicate: =&gt; <span class="type">Boolean</span>) =</span><br><span class="line"><span class="keyword">if</span> (!predicate)</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">AssertionError</span></span><br><span class="line">assert(<span class="number">1</span> &gt; <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(x: <span class="type">Int</span>, y: <span class="type">Int</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">	<span class="keyword">if</span> (x &gt; y) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">assert(compare(<span class="number">1</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure>
<h3 id="可变参函数"><a href="#可变参函数" class="headerlink" title="可变参函数"></a>可变参函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>(args:<span class="type">String</span>*)=&#123;</span><br><span class="line">	<span class="keyword">for</span>(arg &lt;- args) println(arg)</span><br><span class="line">&#125;</span><br><span class="line">echo(<span class="string">"Hello"</span>,<span class="string">"World"</span>,<span class="string">"!"</span>)</span><br><span class="line"><span class="comment">//output: Hello World!</span></span><br></pre></td></tr></table></figure>
<h3 id="管道-pipeline-函数"><a href="#管道-pipeline-函数" class="headerlink" title="管道(pipeline)函数"></a>管道(pipeline)函数</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">even</span></span>(x:<span class="type">Array</span>[<span class="type">Int</span>]):<span class="type">Array</span>[<span class="type">Int</span>]=&#123;</span><br><span class="line">  x.filter(_%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">square</span></span>(x:<span class="type">Array</span>[<span class="type">Int</span>]):<span class="type">Array</span>[<span class="type">Int</span>]=&#123;</span><br><span class="line">  x.map(e=&gt;e*e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">total</span></span>(x:<span class="type">Array</span>[<span class="type">Int</span>]):<span class="type">Int</span>=&#123;</span><br><span class="line">  x.reduce(_+_)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> nums = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="keyword">val</span> pipeline = total(square(even(nums)))</span><br><span class="line"><span class="comment">//output: 220</span></span><br></pre></td></tr></table></figure>
<p><strong>递归函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span></span>(i:<span class="type">Int</span>):<span class="type">Unit</span>= &#123;</span><br><span class="line">	<span class="keyword">if</span> (i &lt; <span class="number">10</span> &amp;&amp; i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		println(<span class="string">s"i:<span class="subst">$i</span>"</span>);</span><br><span class="line">    fun(i + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>Scala编译器优化了尾递归调用，递归调用和执行一个while循环没有性能上区别。</p>
<h3 id="方法与函数"><a href="#方法与函数" class="headerlink" title="方法与函数"></a>方法与函数</h3><p>在Scala中函数如果是某个对象的成员，那么称这种<strong>函数</strong>为<strong>方法</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">		print(<span class="string">"Hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法的访问权限和Java有些不同，没有标注访问权限关键字的方法即为public。</p>
<p><strong>private</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>()=<span class="keyword">new</span> <span class="type">Sample</span></span><br><span class="line">  <span class="comment">//Visible</span></span><br><span class="line">  <span class="type">Sample</span>().sayHello()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">		print(<span class="string">"Hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标注了private关键字，伴生对象和本对象可以访问。</p>
<p><strong>private[this]</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>()=<span class="keyword">new</span> <span class="type">Sample</span></span><br><span class="line">	<span class="comment">//Invisible</span></span><br><span class="line">  <span class="type">Sample</span>().sayHello()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">		print(<span class="string">"Hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为private标注了this限定词,则只有本对象可以访问。</p>
<p><strong>protected</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>()=<span class="keyword">new</span> <span class="type">Sample</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>[scala] <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">		print(<span class="string">"Hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OtherSample</span> <span class="keyword">extends</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">  <span class="comment">//Visible</span></span><br><span class="line">	<span class="type">Sample</span>().sayHello()</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ThirdSample</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Invisible</span></span><br><span class="line">  <span class="type">Sample</span>().sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scala的方法被标注了protedted，就只比private多了能在子类中访问。</p>
<p><strong>protected[packageName]</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.stanley.scala</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sample</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>()=<span class="keyword">new</span> <span class="type">Sample</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sample</span> </span>&#123;</span><br><span class="line">	<span class="keyword">protected</span>[stanley] <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span></span>():<span class="type">Unit</span>=&#123;</span><br><span class="line">		print(<span class="string">"Hello"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">OtherSample</span></span>&#123;</span><br><span class="line">	<span class="comment">//Visible</span></span><br><span class="line">  <span class="type">Sample</span>().sayHello()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过指定protected的限定词，可以指明在包中可见。样例代码中，标明了在 stanley 包中可见。</p>
<p>添加限定词后 。当限定词是Sample时，private[Sample] 等于 private。而protected[Sample]等于protected。当限定词是this时，protected[this] 子类中可见，伴生对象中不可见，private[this]只有本对象可见。当限定词是包名时，private和protected没有区别。</p>
<p>-————————————————————————————————————————————————————</p>
<h2 id="补充：Scala的lambda演算"><a href="#补充：Scala的lambda演算" class="headerlink" title="补充：Scala的lambda演算"></a>补充：Scala的lambda演算</h2><p>为了更好的理解函数式编程，还是补充一部分关于lambda的知识和大家交流。</p>
<p>lambda演算是一套用于研究函数定义、函数应用和递归的形式系统。它由阿隆佐·邱奇和他的学生斯蒂芬·科尔·克莱尼在20世纪30年代引入。邱奇运用λ演算在1936年给出判定性问题的一个否定的答案。这种演算可以用来清晰地定义什么是一个可计算函数。关于两个lambda演算表达式是否等价的命题无法通过一个“通用的算法”来解决，这是不可判定性能够证明的头一个问题，甚至还在停机问题之先。Lambda演算对函数式编程语言有巨大的影响，比如Lisp语言、ML语言和Haskell语言，包括Scala语言。</p>
<p>Lambda演算可以被称为最小的通用程序设计语言。它包括一条变换规则（变量替换）和一条函数定义方式，Lambda演算之通用在于，任何一个可计算函数都能用这种形式来表达和求值。因而，它是等价于图灵机的。尽管如此，Lambda演算强调的是变换规则的运用，而非实现它们的具体机器。可以认为这是一种更接近软件而非硬件的方式。</p>
<h2 id="非形式化的描述"><a href="#非形式化的描述" class="headerlink" title="非形式化的描述"></a>非形式化的描述</h2><p>在lambda演算中，每个表达式都代表一个函数，这个函数有一个参数，并且返回一个值。不论是参数和返回值，也都是一个单参的函数。可以这么说，lambda演算中，只有一种“类型”，那就是这种单参函数。</p>
<p>函数是通过lambda表达式匿名地定义的，这个表达式说明了此函数将对其参数进行什么操作。e.g.，“加2”函数def f(x)= x + 2可以用lambda演算表示为<img src="https://www.zhihu.com/equation?tex=%5Clambda+x.x%2B2" alt="[公式]">。</p>
<p>Scala的表达式</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x)=&gt;x+<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>考虑这么一个函数：它把一个函数作为参数，这个函数将被作用在3上<img src="https://www.zhihu.com/equation?tex=%5Clambda+f.f+3" alt="[公式]"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f3 = (x:<span class="type">Int</span>=&gt;<span class="type">Int</span>)=&gt;x(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>。如果把这个（用函数作参数的）函数作用于我们先前的“加2”函数上<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+f.f+3+%5Cright%29%5Cleft%28+%5Clambda+x.x%2B2+%5Cright%29+" alt="[公式]"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f3(f)</span><br></pre></td></tr></table></figure>
<p>，则明显地，这三个表达式：<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+f.f+3+%5Cright%29%5Cleft%28+%5Clambda+x.x%2B2+%5Cright%29+" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x%2B2+%5Cright%29+3" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=3%2B2" alt="[公式]">是等价的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f3(f)、f(<span class="number">3</span>)、<span class="number">3</span>+<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>有两个参数的函数可以通过lambda演算这么表达：一个单一参数的函数的返回值又是一个单一参数的函数（Currying）。例如，函数<img src="https://www.zhihu.com/equation?tex=f%5Cleft%28+x%2Cy+%5Cright%29+%3Dx-y" alt="[公式]">可以写作<img src="https://www.zhihu.com/equation?tex=%5Clambda+x.%5Clambda+y.x-y" alt="[公式]">。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span></span>(x:<span class="type">Int</span>, y:<span class="type">Int</span>) = x - y</span><br><span class="line"><span class="comment">//Can this</span></span><br><span class="line">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)=&gt;x-y</span><br></pre></td></tr></table></figure>
<p>这三个表达式：作<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.%5Clambda+y.x-y+%5Cright%29+7+2" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+y.7-y+%5Cright%29+2" alt="[公式]">、<img src="https://www.zhihu.com/equation?tex=7-2" alt="[公式]">也是等价的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((x:<span class="type">Int</span>,y:<span class="type">Int</span>)=&gt;x-y)(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">((y:<span class="type">Int</span>)=&gt;<span class="number">7</span>-y)(<span class="number">2</span>)</span><br><span class="line"><span class="number">7</span><span class="number">-2</span></span><br></pre></td></tr></table></figure>
<p>然而这种lambda表达式之间的等价性无法找到一个通用的函数来判定。</p>
<p>并非所有的lambda表达式都可以规约至上述那样的确定值，考虑<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+" alt="[公式]">或<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+" alt="[公式]"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(<span class="number">0</span>))))</span><br><span class="line"><span class="comment">//OR</span></span><br><span class="line">((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(((x:<span class="type">Int</span>)=&gt;x)(<span class="number">0</span>))))))</span><br></pre></td></tr></table></figure>
<p>（注意:0只是个参数）</p>
<p>然后试图把第一个函数作用在它的参数上。<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+" alt="[公式]">被称为ω 组合子，<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+%5Cright%29+" alt="[公式]">被称为Ω，而<img src="https://www.zhihu.com/equation?tex=%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+%5Cleft%28+%5Clambda+x.x+x+x+%5Cright%29+" alt="[公式]">被称为Ω2，以此类推。</p>
<h2 id="lambda演算中的算术"><a href="#lambda演算中的算术" class="headerlink" title="lambda演算中的算术"></a>lambda演算中的算术</h2><p>在lambda演算中有许多方式都可以定义自然数，但最常见的是<strong>Church数。</strong>邱奇整数是一个高阶函数，以单一参数函数f为参数，返回另一个单一参数的函数。利用函数被调用的次数标识自然数。</p>
<p><img src="https://www.zhihu.com/equation?tex=0%3D%5Clambda+f.%5Clambda+x.x" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=1%3D%5Clambda+f.%5Clambda+x.f+x" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=2%3D%5Clambda+f.%5Clambda+x.f+%5Cleft%28+f+x+%5Cright%29+" alt="[公式]"></p>
<p><img src="https://www.zhihu.com/equation?tex=3%3D%5Clambda+f.%5Clambda+x.f+x%5Cleft%28+f+%5Cleft%28+f+x+%5Cright%29+%5Cright%29+" alt="[公式]"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Scala Sample</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zero</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">A</span>) = (x: <span class="type">A</span>) =&gt; x</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">A</span>) = (x: <span class="type">A</span>) =&gt; f(x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">A</span>) = (x: <span class="type">A</span>) =&gt; f(f(x))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">three</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">A</span>) = (x: <span class="type">A</span>) =&gt; f(f(f(x)))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">four</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">A</span>) = (x: <span class="type">A</span>) =&gt; f(f(f(f(x))))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">five</span></span>[<span class="type">A</span>](f: <span class="type">A</span> =&gt; <span class="type">A</span>) = (x: <span class="type">A</span>) =&gt; f(f(f(f(f(x)))))</span><br><span class="line">println(<span class="string">"zero: "</span> + zero[<span class="type">Int</span>](i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br><span class="line">println(<span class="string">"one: "</span> + one[<span class="type">Int</span>](i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br><span class="line">println(<span class="string">"two: "</span> + two[<span class="type">Int</span>](i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br><span class="line">println(<span class="string">"three: "</span> + three[<span class="type">Int</span>](i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br><span class="line">println(<span class="string">"four: "</span> + four[<span class="type">Int</span>](i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br><span class="line">println(<span class="string">"four: "</span> + five[<span class="type">Int</span>](i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>Church数定义的基础上，我们可以定义一个后继函数，它以n为参数，返回n + 1<img src="https://www.zhihu.com/equation?tex=SUCC%3D%5Clambda+n.%5Clambda+f.%5Clambda+x.f%5Cleft%28+n+f+x+%5Cright%29+" alt="[公式]"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">succ</span></span>[<span class="type">A</span>](n: (<span class="type">A</span> =&gt; <span class="type">A</span>) =&gt; <span class="type">A</span> =&gt; <span class="type">A</span>) = (f: <span class="type">A</span> =&gt; <span class="type">A</span>) =&gt; (x: <span class="type">A</span>) =&gt; f(n(f)(x))</span><br><span class="line">println(<span class="string">"succ: "</span> + succ[<span class="type">Int</span>](two)(i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>定义加法<img src="https://www.zhihu.com/equation?tex=PLUS%3D%5Clambda+m.%5Clambda+n.%5Clambda+f.%5Clambda+x.m+f%5Cleft%28+n+f+x+%5Cright%29+" alt="[公式]"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>[<span class="type">A</span>](m: (<span class="type">A</span> =&gt; <span class="type">A</span>) =&gt; <span class="type">A</span> =&gt; <span class="type">A</span>) = (n: (<span class="type">A</span> =&gt; <span class="type">A</span>) =&gt; <span class="type">A</span> =&gt; <span class="type">A</span>) =&gt; (f: <span class="type">A</span> =&gt; <span class="type">A</span>) =&gt; (x: <span class="type">A</span>) =&gt; m(f)(n(f)(x))</span><br><span class="line">println(<span class="string">"plus: "</span> + plus[<span class="type">Int</span>](three)(two)(i =&gt; i + <span class="number">1</span>)(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>乘法可以这样定义</p>
<p><img src="https://www.zhihu.com/equation?tex=MULT%3D%5Clambda+m.%5Clambda+f.%5Clambda+n.m+%5Cleft%28+n+f+%5Cright%29+" alt="[公式]"></p>
<p>原始链接：<a href="https://zhuanlan.zhihu.com/p/25484213" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25484213</a></p>
<h1 id="集合数据操作"><a href="#集合数据操作" class="headerlink" title="集合数据操作"></a>集合数据操作</h1><p>scala.collection.TraversableOnce：定义了可遍历集合的操作</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span></span>: <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否不为空</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nonEmpty</span></span>: <span class="type">Boolean</span> = !isEmpty</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对满足p条件的元素计数，默认直接传True即可</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">   <span class="keyword">var</span> cnt = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> (x &lt;- <span class="keyword">this</span>)</span><br><span class="line">     <span class="keyword">if</span> (p(x)) cnt += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">   cnt</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对集合中的每个元素施加f操作，没有返回值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>](f: <span class="type">A</span> =&gt; <span class="type">U</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查某个元素在集合中是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exists</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">Boolean</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到第一个满足p条件的元素，返回一个Option对象，表示可能找不到</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">Option</span>[<span class="type">A</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foldLeft的别名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">/</span></span>:[<span class="type">B</span>](z: <span class="type">B</span>)(op: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = foldLeft(z)(op)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">// 最重要的一个方法。很多方法基本都是基于此方法演化出来的</span></span><br><span class="line"><span class="comment">// 对当前的集合的每一个元素 从左到右的施加一个有初始值(z)二值操作(op)</span></span><br><span class="line"><span class="comment">// 返回类型B与初始值z的类型一致</span></span><br><span class="line"><span class="comment">// op接收的两个参数类型分别为：B和A，A为原始集合元素的类型；B是op每一次处理的结果；初始情况：B=z</span></span><br><span class="line"> <span class="comment">// 最终的效果是：1-&gt;2-&gt;3-&gt;4  z  op(op(op(op(z, 1), 2), 3), 4)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(op: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = &#123;</span><br><span class="line">   <span class="keyword">var</span> result = z</span><br><span class="line">   <span class="keyword">this</span> foreach (x =&gt; result = op(result, x))</span><br><span class="line">   result</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foldRight的别名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> </span>:\[<span class="type">B</span>](z: <span class="type">B</span>)(op: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = foldRight(z)(op)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">B</span>](z: <span class="type">B</span>)(op: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> =</span><br><span class="line">  reversed.foldLeft(z)((x, y) =&gt; op(y, x))</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将集合中的元素从左到右的施加一个二值操作(op)</span></span><br><span class="line"><span class="comment">// 返回结果类型是集合元素本身的类型或者是其父类型</span></span><br><span class="line"><span class="comment">// 1-&gt;2-&gt;3-&gt;4 op(op(op(1, 2), 3), 4)</span></span><br><span class="line"><span class="comment">// 实质上就是没有初始值的foldLeft</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceLeft</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](op: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(<span class="string">"empty.reduceLeft"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> first = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">var</span> acc: <span class="type">B</span> = <span class="number">0.</span>asInstanceOf[<span class="type">B</span>]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (x &lt;- self) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first) &#123;</span><br><span class="line">      acc = x</span><br><span class="line">      first = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> acc = op(acc, x)</span><br><span class="line">  &#125;</span><br><span class="line">  acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceRight</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](op: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(<span class="string">"empty.reduceRight"</span>)</span><br><span class="line"></span><br><span class="line">  reversed.reduceLeft[<span class="type">B</span>]((x, y) =&gt; op(y, x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 集合为空的时候返回None，不为空的时候返回执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceLeftOption</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](op: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] =</span><br><span class="line">  <span class="keyword">if</span> (isEmpty) <span class="type">None</span> <span class="keyword">else</span> <span class="type">Some</span>(reduceLeft(op))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceRightOption</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](op: (<span class="type">A</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">Option</span>[<span class="type">B</span>] =</span><br><span class="line">  <span class="keyword">if</span> (isEmpty) <span class="type">None</span> <span class="keyword">else</span> <span class="type">Some</span>(reduceRight(op))</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = reduceLeft(op)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceOption</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">Option</span>[<span class="type">A1</span>] = reduceLeftOption(op)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](z: <span class="type">A1</span>)(op: (<span class="type">A1</span>, <span class="type">A1</span>) =&gt; <span class="type">A1</span>): <span class="type">A1</span> = foldLeft(z)(op)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">B</span>](z: =&gt;<span class="type">B</span>)(seqop: (<span class="type">B</span>, <span class="type">A</span>) =&gt; <span class="type">B</span>, combop: (<span class="type">B</span>, <span class="type">B</span>) =&gt; <span class="type">B</span>): <span class="type">B</span> = foldLeft(z)(seqop)</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用foldLeft来实现求和  必须是数字类型的元素</span></span><br><span class="line"><span class="comment">// z=num.zero</span></span><br><span class="line"><span class="comment">// op=num.plus</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> num: <span class="type">Numeric</span>[<span class="type">B</span>]): <span class="type">B</span> = foldLeft(num.zero)(num.plus)</span><br><span class="line"><span class="comment">// z=num.one</span></span><br><span class="line"><span class="comment">// op=num.times</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">product</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> num: <span class="type">Numeric</span>[<span class="type">B</span>]): <span class="type">B</span> = foldLeft(num.one)(num.times)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会自动寻找Numeric的隐式转换对象，使用sun和product时只需要直接调用即可</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的op=(x, y) =&gt; if (cmp.lteq(x, y)) x else y</span></span><br><span class="line"><span class="comment">// 会自动去寻找Ordering的隐式转换对象，如果是原始元素就是数字类型的，那么这个参数可以不用传，但是如果原始元素类型不是数字这样可比较的类型，那么需要自顶一个Ordering规则，作为参数传递进来</span></span><br><span class="line"><span class="comment">// 或者原始的元素类型实现了java.util.Comparator接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> cmp: <span class="type">Ordering</span>[<span class="type">B</span>]): <span class="type">A</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(<span class="string">"empty.min"</span>)</span><br><span class="line"></span><br><span class="line">  reduceLeft((x, y) =&gt; <span class="keyword">if</span> (cmp.lteq(x, y)) x <span class="keyword">else</span> y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> cmp: <span class="type">Ordering</span>[<span class="type">B</span>]): <span class="type">A</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (isEmpty)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(<span class="string">"empty.max"</span>)</span><br><span class="line"></span><br><span class="line">  reduceLeft((x, y) =&gt; <span class="keyword">if</span> (cmp.gteq(x, y)) x <span class="keyword">else</span> y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scala.collection.TraversableLike</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对集合中的每个元素施加一个f操作，数据类型发生了从A到B的变化，</span></span><br><span class="line"><span class="comment">// 返回结果是一个size一样的集合，但是元素类型不一样</span></span><br><span class="line"><span class="comment">// [1,2,3,4]   [f(1),f(2),f(3),f(4)]</span></span><br><span class="line"><span class="comment">// [[1,2,3],[4,5,6],[7,8]]  [f([1,2,3]),f([4,5,6]),f([7,8])]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">B</span>, <span class="type">That</span>](f: <span class="type">A</span> =&gt; <span class="type">B</span>)(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">builder</span> </span>= &#123; </span><br><span class="line">    <span class="keyword">val</span> b = bf(repr)</span><br><span class="line">    b.sizeHint(<span class="keyword">this</span>)</span><br><span class="line">    b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> b = builder</span><br><span class="line">  <span class="keyword">for</span> (x &lt;- <span class="keyword">this</span>) b += f(x)</span><br><span class="line">  b.result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理与map类似，但是增加了一个扁平化的处理：</span></span><br><span class="line"><span class="comment">// 效果如下：[[1,2,3],[4,5,6],[7,8]]   </span></span><br><span class="line"><span class="comment">// [f([1,2,3])[0],f([1,2,3])[1],f([1,2,3])[2],f([4,5,6])[0],f([4,5,6])[1],f([4,5,6])[2],f([7,8])[0],f([7,8])[1],f([7,8])[2]]</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">B</span>, <span class="type">That</span>](f: <span class="type">A</span> =&gt; <span class="type">GenTraversableOnce</span>[<span class="type">B</span>])(<span class="keyword">implicit</span> bf: <span class="type">CanBuildFrom</span>[<span class="type">Repr</span>, <span class="type">B</span>, <span class="type">That</span>]): <span class="type">That</span> = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">builder</span> </span>= bf(repr) </span><br><span class="line">  <span class="keyword">val</span> b = builder</span><br><span class="line">  <span class="keyword">for</span> (x &lt;- <span class="keyword">this</span>) b ++= f(x).seq</span><br><span class="line">  b.result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤出来集合中元素满足p条件的元素，结果为一个新的集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">filterImpl</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>, isFlipped: <span class="type">Boolean</span>): <span class="type">Repr</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> b = newBuilder</span><br><span class="line">    <span class="keyword">for</span> (x &lt;- <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">if</span> (p(x) != isFlipped) b += x</span><br><span class="line"></span><br><span class="line">    b.result</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(p: <span class="type">A</span> =&gt; <span class="type">Boolean</span>): <span class="type">Repr</span> = filterImpl(p, isFlipped = <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/函数式编程/" rel="tag"># 函数式编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/Scala学习-编程Tips/" rel="prev" title="Scala学习-编程Tips">
      <i class="fa fa-chevron-left"></i> Scala学习-编程Tips
    </a></div>
      <div class="post-nav-item">
    <a href="/post/Java学习-String/" rel="next" title="Java学习-String">
      Java学习-String <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是函数式编程"><span class="nav-number">1.</span> <span class="nav-text">什么是函数式编程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#定义"><span class="nav-number">2.</span> <span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#命令式编程-Imperative"><span class="nav-number">2.1.</span> <span class="nav-text">命令式编程(Imperative)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数式编程-functional"><span class="nav-number">2.2.</span> <span class="nav-text">函数式编程(functional)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#普通函数"><span class="nav-number">2.2.1.</span> <span class="nav-text">普通函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#匿名函数"><span class="nav-number">2.2.2.</span> <span class="nav-text">匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无参匿名函数"><span class="nav-number">2.2.3.</span> <span class="nav-text">无参匿名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高阶函数"><span class="nav-number">2.2.4.</span> <span class="nav-text">高阶函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#嵌入式函数-本地函数"><span class="nav-number">2.2.5.</span> <span class="nav-text">嵌入式函数(本地函数)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数柯里化-Currying"><span class="nav-number">2.2.6.</span> <span class="nav-text">函数柯里化(Currying)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#部分应用函数"><span class="nav-number">2.2.7.</span> <span class="nav-text">部分应用函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏函数-Partial-Function"><span class="nav-number">2.2.8.</span> <span class="nav-text">偏函数(Partial Function)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#闭包"><span class="nav-number">2.2.9.</span> <span class="nav-text">闭包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传值调用函数-call-by-value"><span class="nav-number">2.2.10.</span> <span class="nav-text">传值调用函数(call by value)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传名调用函数-call-by-name"><span class="nav-number">2.2.11.</span> <span class="nav-text">传名调用函数(call by name)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参函数"><span class="nav-number">2.2.12.</span> <span class="nav-text">可变参函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道-pipeline-函数"><span class="nav-number">2.2.13.</span> <span class="nav-text">管道(pipeline)函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法与函数"><span class="nav-number">2.2.14.</span> <span class="nav-text">方法与函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充：Scala的lambda演算"><span class="nav-number">2.3.</span> <span class="nav-text">补充：Scala的lambda演算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非形式化的描述"><span class="nav-number">2.4.</span> <span class="nav-text">非形式化的描述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda演算中的算术"><span class="nav-number">2.5.</span> <span class="nav-text">lambda演算中的算术</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#集合数据操作"><span class="nav-number">3.</span> <span class="nav-text">集合数据操作</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">王尚</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">148</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王尚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>