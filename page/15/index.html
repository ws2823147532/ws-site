<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"ws2823147532.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="努力，奋斗">
<meta property="og:url" content="https://ws2823147532.github.io/ws-site/page/15/index.html">
<meta property="og:site_name" content="努力，奋斗">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="努力，奋斗">

<link rel="canonical" href="https://ws2823147532.github.io/ws-site/page/15/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>努力，奋斗</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">努力，奋斗</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">记录学习</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/JAVA并发编程-1-内存模型JMM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/JAVA并发编程-1-内存模型JMM/" class="post-title-link" itemprop="url">JAVA并发编程-1-内存模型JMM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-03 10:50:11" itemprop="dateCreated datePublished" datetime="2020-06-03T10:50:11+08:00">2020-06-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-11 16:17:49" itemprop="dateModified" datetime="2020-12-11T16:17:49+08:00">2020-12-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA并发编程/" itemprop="url" rel="index"><span itemprop="name">JAVA并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="硬件层的并发优化基础"><a href="#硬件层的并发优化基础" class="headerlink" title="硬件层的并发优化基础"></a>硬件层的并发优化基础</h2><p><img src="/images/image-20200827133335886.png" alt="image-20200827133335886"></p>
<p><img src="/images/image-20200827133600227.png" alt="image-20200827133600227"></p>
<p>为了解决CPU速度和内存、磁盘的速度的差异(从上图可以看出，差异是很大的)带来的资源应用不均衡的问题，在硬件层是做了很多优化的，其中一个就是增加<strong>多级缓存机制</strong>，该机制会利用<strong>局部性原理</strong>(访问某个数据，那么它附近的数据将很有可能被访问)，将最近被访问的数据做一层缓存，那么下次再次访问该数据的时候，速度会快很多。</p>
<p><img src="/images/image-20200827133837208.png" alt="image-20200827133837208"></p>
<p>其中L1和L2级缓存是与CPU核绑定的，那么这就有可能导致一个问题：在并发环境下不同的核在做L1和L2缓存的时候，可能会导致两者缓存的数据不一致的问题，即Core1和Core2同时缓存了一个变量x，但是在Core1把它修改了，这个时候Core2的缓存实际桑上就不对了。那么如何进行同步呢？</p>
<p>硬件层缓存一致性</p>
<ul>
<li><p>总线锁：老的CPU</p>
</li>
<li><p>数据一致性协议  MESI Cache一致性协议   <strong>是一种缓存锁</strong></p>
<ul>
<li><p><img src="/images/image-20200827135021022.png" alt="image-20200827135021022"></p>
</li>
<li><p>协议很多</p>
<p>intel 用MESI，给每个缓存的内容作了一个标记</p>
<p><strong>M: 被修改（Modified)</strong></p>
<p>该缓存行只被缓存在该<code>CPU</code>的缓存中，并且是被修改过的（<code>dirty</code>),即与主存中的数据不一致，该缓存行中的内存需要在未来的某个时间点（允许其它<code>CPU</code>读取请主存中相应内存之前）写回（<code>write back</code>）主存。</p>
<p>当被写回主存之后，该缓存行的状态会变成独享（<code>exclusive</code>)状态。</p>
<p><strong>E: 独享的（Exclusive)</strong></p>
<p>该缓存行只被缓存在该<code>CPU</code>的缓存中，它是未被修改过的（<code>clean</code>)，与主存中数据一致。该状态可以在任何时刻当有其它<code>CPU</code>读取该内存时变成共享状态（<code>shared</code>)。</p>
<p>同样地，当<code>CPU</code>修改该缓存行中内容时，该状态可以变成<code>Modified</code>状态。</p>
<p><strong>S: 共享的（Shared)</strong></p>
<p>该状态意味着该缓存行可能被多个<code>CPU</code>缓存，并且各个缓存中的数据与主存数据一致（<code>clean</code>)，当有一个<code>CPU</code>修改该缓存行中，其它<code>CPU</code>中该缓存行可以被作废（变成无效状态（<code>Invalid</code>））。</p>
<p><strong>I: 无效的（Invalid）</strong></p>
<p>该缓存是无效的（可能有其它<code>CPU</code>修改了该缓存行）。</p>
<p><a href="https://www.cnblogs.com/z00377750/p/9180644.html" target="_blank" rel="noopener">https://www.cnblogs.com/z00377750/p/9180644.html</a></p>
<p>现代CPU的数据一致性实现 = 缓存锁(MESI …) + 总线锁</p>
</li>
</ul>
</li>
</ul>
<h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>读取缓存以<code>cache line</code>为基本单位，目前64bytes</p>
<p>位于同一缓存行的两个不同数据，被两个不同CPU锁定，产生互相影响的伪共享问题</p>
<p>伪共享问题：JUC/c_028_FalseSharing</p>
<p>使用缓存行的对齐能够提高效率</p>
<p><img src="/images/image-20200921072258470.png" alt="image-20200921072258470"></p>
<h3 id="乱序执行"><a href="#乱序执行" class="headerlink" title="乱序执行"></a>乱序执行</h3><p>CPU为了提高指令执行效率，会在一条指令执行过程中（比如去内存读取数据（慢100倍）），他会去同时执行另一条指令，前提是，两条指令没有依赖关系</p>
<p><a href="https://www.cnblogs.com/liushaodong/p/4777308.html" target="_blank" rel="noopener">https://www.cnblogs.com/liushaodong/p/4777308.html</a></p>
<p><img src="/images/image-20200921072722103.png" alt="image-20200921072722103"></p>
<p>写操作也可以合并： 合并写：WC Buffer，Write Combiner Buffer。一般只有4Bytes，位于比L1缓存还高的级别</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JUC/029_WriteCombining</span><br><span class="line"></span><br><span class="line">乱序执行的证明：JVM/jmm/Disorder.java</span><br><span class="line"></span><br><span class="line">原始参考：https://preshing.com/20120515/memory-reordering-caught-in-the-act/</span><br></pre></td></tr></table></figure>
<h3 id="如何保证特定情况下-不乱序"><a href="#如何保证特定情况下-不乱序" class="headerlink" title="如何保证特定情况下 不乱序"></a>如何保证特定情况下 不乱序</h3><h4 id="硬件级别的内存屏障："><a href="#硬件级别的内存屏障：" class="headerlink" title="硬件级别的内存屏障："></a>硬件级别的内存屏障：</h4><p>Intel的CPU的汇编指令</p>
<p>sfence： save fence</p>
<p>lfence： load fence</p>
<p>mfence： modify fence</p>
<p><img src="/images/image-20200922074104788.png" alt="image-20200922074104788"></p>
<p>原子指令：如x86上的<code>lock ...</code>指令是一个FullBarrier，执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。Sofeware Locks通常是使用了内存屏障或原子指令来实现变量的可见性和保持程序的顺序</p>
<h4 id="JVM级别的内存屏障"><a href="#JVM级别的内存屏障" class="headerlink" title="JVM级别的内存屏障"></a>JVM级别的内存屏障</h4><p><img src="/images/image-20200922075433859.png" alt="image-20200922075433859"></p>
<h4 id="volatile的实现细节"><a href="#volatile的实现细节" class="headerlink" title="volatile的实现细节"></a>volatile的实现细节</h4><ol>
<li>字节码层面</li>
</ol>
<p>​    在编译成字节码的时候，被标记字段的accessflags为<code>0x0040</code>，即加了一个volatile的标记</p>
<ol>
<li><p>JVM层面</p>
<p>在volatile变量的读写操作前后会加入不同的内存屏障，保证volatile变量读写操作不会发生乱序</p>
<p><img src="/images/image-20200922080054350.png" alt="image-20200922080054350"></p>
</li>
</ol>
<ol>
<li><p>OS和硬件层面</p>
<p>   <a href="https://blog.csdn.net/qq_26222859/article/details/52235930" target="_blank" rel="noopener">https://blog.csdn.net/qq_26222859/article/details/52235930</a><br>   hsdis - HotSpot Dis Assembler<br>   windows lock 指令实现 | MESI实现</p>
</li>
</ol>
<h4 id="synchronized实现细节"><a href="#synchronized实现细节" class="headerlink" title="synchronized实现细节"></a>synchronized实现细节</h4><ol>
<li>字节码层面<br>ACC_SYNCHRONIZED<br>monitorenter monitorexit</li>
<li>JVM层面<br>C C++ 调用了操作系统提供的同步机制</li>
<li>OS和硬件层面<br>X86 : lock cmpxchg / xxx<br><a href="https://blog.csdn.net/21aspnet/article/details/88571740" target="_blank" rel="noopener">https</a><a href="https://blog.csdn.net/21aspnet/article/details/88571740" target="_blank" rel="noopener">://blog.csdn.net/21aspnet/article/details/</a><a href="https://blog.csdn.net/21aspnet/article/details/88571740" target="_blank" rel="noopener">88571740</a></li>
</ol>
<p>java并发内存模型</p>
<p><img src="/images/image-20200928075314211.png" alt="image-20200928075314211"></p>
<p>Happened-Before原则</p>
<p><img src="/images/image-20200928075352744.png" alt="image-20200928075352744"></p>
<p>as-is-serial</p>
<p><img src="/images/image-20200928075525079.png" alt="image-20200928075525079"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Spark应用-Scheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Spark应用-Scheduler/" class="post-title-link" itemprop="url">Spark应用-Scheduler</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 14:22:50" itemprop="dateCreated datePublished" datetime="2020-06-01T14:22:50+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-07 09:51:09" itemprop="dateModified" datetime="2021-05-07T09:51:09+08:00">2021-05-07</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Spark任务有四种提交方式：</p>
<ul>
<li>local</li>
<li>standalone</li>
<li>yarn(这里着重讲)</li>
<li>mesos</li>
</ul>
<p>这里涉及到两层的任务调度：</p>
<h5 id="第一层：schedule-across-applications，应用间的任务调度"><a href="#第一层：schedule-across-applications，应用间的任务调度" class="headerlink" title="第一层：schedule across applications，应用间的任务调度"></a>第一层：schedule across applications，应用间的任务调度</h5><p>Spark的application提交到yarn平台，yarn平台负责Spark application的调度，这里也分为两层：</p>
<h6 id="第一层：Yarn的队列，Spark-application和其他运行在Yarn平台上的应用并无二致，都要统一服从yarn平台的安排"><a href="#第一层：Yarn的队列，Spark-application和其他运行在Yarn平台上的应用并无二致，都要统一服从yarn平台的安排" class="headerlink" title="第一层：Yarn的队列，Spark application和其他运行在Yarn平台上的应用并无二致，都要统一服从yarn平台的安排"></a>第一层：<a href="https://blog.csdn.net/bingduanlbd/article/details/52000151" target="_blank" rel="noopener">Yarn的队列</a>，Spark application和其他运行在Yarn平台上的应用并无二致，都要统一服从yarn平台的安排</h6><p>yarn有三种任务调度模型：</p>
<ul>
<li>FIFO scheduler：先入先出调度器，整个Yarn集群只有一个任务队列，所有提交的任务都要等待上一个任务完全执行完才能执行，除非集群中有空闲的资源</li>
</ul>
<p><img src="/images/image-20201218111253237.png" alt="image-20201218111253237"></p>
<ul>
<li>Capacity scheduler：容量调度器，以Capacity为中心，把资源划分到若干个队列中，各个队列内根据自己的逻辑分配资源。例如下图中队列A可以调度的资源可以占80%，队列B占有剩下的20%，各队列接受相应的作业请求，在自己的资源中分配</li>
</ul>
<p><img src="/images/image-20201218111318397.png" alt="image-20201218111318397"></p>
<ul>
<li>Fair scheduler：秉承公平性原则，尽可能让各个作业得到的资源平均。先提交的job1马上占满了集群资源，那么作业2提交之后，原本Job1占有的资源拨出一些给作业2，从而达到“公平”<strong>(但是要等到job1的某些task执行完毕之后才能把资源让出来)</strong></li>
</ul>
<p><img src="/images/image-20201218111337942.png" alt="image-20201218111337942"></p>
<h6 id="第二层：Yarn队列内的调度"><a href="#第二层：Yarn队列内的调度" class="headerlink" title="第二层：Yarn队列内的调度"></a>第二层：Yarn队列内的调度</h6><p>当使用FIFO scheduler，自不必说，它只有一个先进先出的队列，也就是队列内部的任务调度；Capacity scheduler会把 集群分成若干个队列，每个队列内部采用FIFO的策略；Fair scheduler可以通过设置，每个Fair Queue内部使用不同的schedulingPolicy，但是会有一个文档级别的默认策略的配置defaultQueueSchedulingPolicy，如果每个Queue没有自己的设置，那么就用defaultQueueSchedulingPolicy</p>
<h5 id="第二层：schedule-within-application，同一个SparkContext内的job调度"><a href="#第二层：schedule-within-application，同一个SparkContext内的job调度" class="headerlink" title="第二层：schedule within application，同一个SparkContext内的job调度"></a>第二层：schedule within application，同一个SparkContext内的job调度</h5><p><a href="https://bruce.blog.csdn.net/article/details/88349295" target="_blank" rel="noopener">谈Spark下并行执行多个Job的问题</a></p>
<p><a href="https://www.tuicool.com/articles/r2qA7vm" target="_blank" rel="noopener">一次 Spark SQL 性能提升10倍的经历</a></p>
<p><a href="https://ieevee.com/tech/2016/07/11/spark-scheduler.html" target="_blank" rel="noopener">Spark调度（一）：Task调度算法，FIFO还是FAIR</a></p>
<p><a href="https://blog.csdn.net/bingduanlbd/article/details/52000151" target="_blank" rel="noopener">理解YARN Scheduler</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/分布式常见思想-Bloomfilter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/分布式常见思想-Bloomfilter/" class="post-title-link" itemprop="url">分布式常见思想-Bloomfilter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-01 09:58:27 / 修改时间：09:58:58" itemprop="dateCreated datePublished" datetime="2020-06-01T09:58:27+08:00">2020-06-01</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/数据结构与算法学习笔记-内存不足/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/数据结构与算法学习笔记-内存不足/" class="post-title-link" itemprop="url">数据结构与算法学习笔记-内存不足</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 07:35:34" itemprop="dateCreated datePublished" datetime="2020-06-01T07:35:34+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 19:07:58" itemprop="dateModified" datetime="2020-07-02T19:07:58+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中位数定义：数字排序之后，位于中间的那个数。比如将100亿个数字进行排序，排序之后，位于第50亿个位置的那个数 就是中位数。 </p>
<p>  ①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？ </p>
<p>  ②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。 </p>
<p>  假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。 </p>
<p>  从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中） </p>
<p>  现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。 </p>
<p>  现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。 </p>
<p>  抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。 </p>
<p>  按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Java学习-Future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Java学习-Future/" class="post-title-link" itemprop="url">Java学习-Future</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-01 06:44:35" itemprop="dateCreated datePublished" datetime="2020-06-01T06:44:35+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-03 17:32:37" itemprop="dateModified" datetime="2020-06-03T17:32:37+08:00">2020-06-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA学习/" itemprop="url" rel="index"><span itemprop="name">JAVA学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Python学习-一些常见的操作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Python学习-一些常见的操作/" class="post-title-link" itemprop="url">Python学习-一些常见的操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-29 17:15:13" itemprop="dateCreated datePublished" datetime="2020-05-29T17:15:13+08:00">2020-05-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-19 10:25:10" itemprop="dateModified" datetime="2021-05-19T10:25:10+08:00">2021-05-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>把global语句放到函数的开头</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><ul>
<li>如何初始化一个一维数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line">l = [<span class="number">0</span>]*n</span><br><span class="line">l1 = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br></pre></td></tr></table></figure>
<ul>
<li>如何初始化一个二维数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="number">10</span>, <span class="number">7</span></span><br><span class="line">l = [[<span class="number">0</span>]*m]*n   <span class="comment"># 会有赋值问题：n个[0]*m 实际上都是同一个对象</span></span><br><span class="line">l1 = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]  <span class="comment"># 没有赋值问题</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如何初始化一个二维数组并且设置右边界和下边界为1(根据实际情况处理)</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m, n = <span class="number">10</span>, <span class="number">7</span></span><br><span class="line">dp = [[<span class="number">1</span> <span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">or</span> j == n - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(m)] <span class="keyword">for</span> j <span class="keyword">in</span> range(n)]</span><br></pre></td></tr></table></figure>
<ul>
<li>正序遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<ul>
<li>倒序遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">10</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<ul>
<li>数组的元素拼接</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[str(x)+y+str(z) <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> (<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>) <span class="keyword">for</span> z <span class="keyword">in</span> (<span class="string">'0'</span>,<span class="string">'9'</span>)]</span><br></pre></td></tr></table></figure>
<ul>
<li>二维数组一维化</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">b=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">c=list(chain(*b))</span><br><span class="line">print(c)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">ab = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">print([i <span class="keyword">for</span> item <span class="keyword">in</span> ab <span class="keyword">for</span> i <span class="keyword">in</span> item])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>]]</span><br><span class="line">print(reduce(operator.add, a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">a = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>, <span class="number">8</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">l=[]</span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a[m]:</span><br><span class="line">        l.append(i)</span><br><span class="line">print(l)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">a=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">5</span>,<span class="number">8</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">a= eval(<span class="string">'['</span>+str(a).replace(<span class="string">' '</span>,<span class="string">''</span>).replace(<span class="string">'['</span>,<span class="string">''</span>).replace(<span class="string">']'</span>,<span class="string">''</span>)+<span class="string">']'</span>)</span><br><span class="line">print(a)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(a, (list, )):</span><br><span class="line">        <span class="keyword">return</span> [a]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b = []</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">            b += flatten(item)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [[[<span class="number">1</span>,<span class="number">2</span>],<span class="number">3</span>],[<span class="number">4</span>,[<span class="number">5</span>,<span class="number">6</span>]],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</span><br><span class="line">    print(flatten(a))</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如何拷贝一个一维数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">y = x[:]</span><br></pre></td></tr></table></figure>
<ul>
<li>如何拷贝一个二维数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">x=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line">y = [row[:] <span class="keyword">for</span> row <span class="keyword">in</span> x]</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">x=[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> copy, deepcopy</span><br><span class="line">y = deepcopy(x)</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">old_array = [[<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]]</span><br><span class="line"><span class="comment"># python2.*</span></span><br><span class="line">new_array = map(list, old_array)</span><br><span class="line"><span class="comment"># python3.*</span></span><br><span class="line">new_array = list(map(list, old_array))</span><br><span class="line"><span class="comment">### --------------------------------------------------------------------------------</span></span><br><span class="line">arr = [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"></span><br><span class="line">deepcopy1d2d = <span class="keyword">lambda</span> lVals: [x <span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list) <span class="keyword">else</span> x[:] <span class="keyword">for</span> x <span class="keyword">in</span> lVals]</span><br><span class="line"></span><br><span class="line">dst = deepcopy1d2d(arr)</span><br><span class="line"></span><br><span class="line">dst[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">150</span></span><br><span class="line"><span class="keyword">print</span> dst</span><br><span class="line"><span class="keyword">print</span> arr</span><br></pre></td></tr></table></figure>
<h4 id="set的操作"><a href="#set的操作" class="headerlink" title="set的操作"></a>set的操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = t | s          <span class="comment"># t 和 s的并集  </span></span><br><span class="line">  </span><br><span class="line">b = t &amp; s          <span class="comment"># t 和 s的交集  </span></span><br><span class="line">  </span><br><span class="line">c = t – s          <span class="comment"># 求差集（项在t中，但不在s中）  </span></span><br><span class="line">  </span><br><span class="line">d = t ^ s          <span class="comment"># 对称差集（项在t或s中，但不会同时出现在二者中）</span></span><br></pre></td></tr></table></figure>
<h4 id="ascii码的转换"><a href="#ascii码的转换" class="headerlink" title="ascii码的转换"></a>ascii码的转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取一个字符的ascii码</span></span><br><span class="line">ord(<span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将ascii码转换成字符</span></span><br><span class="line">chr(<span class="number">97</span>)</span><br></pre></td></tr></table></figure>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 内存地址</span></span><br><span class="line">a = <span class="number">9</span></span><br><span class="line">id(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一个对象内存占用大小(变量所占字节的大小)</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.getsizeof(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变量类型</span></span><br><span class="line">type(a)</span><br></pre></td></tr></table></figure>
<h4 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二进制</span></span><br><span class="line">Ob1010</span><br><span class="line"><span class="comment"># 获取一个数字的二进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">3</span>)</span><br><span class="line"><span class="string">'0b11'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">-10</span>)</span><br><span class="line"><span class="string">'-0b1010'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 八进制</span></span><br><span class="line"><span class="number">0o176</span></span><br><span class="line"><span class="comment"># 获取一个数字的二进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">3</span>)</span><br><span class="line"><span class="string">'0o3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">-3</span>)</span><br><span class="line"><span class="string">'-0o3'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制</span></span><br><span class="line"><span class="number">43</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 十六进制</span></span><br><span class="line"><span class="number">0x12ab</span></span><br><span class="line">hex(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'0x3'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2 8 16 进制转换成 十进制</span></span><br><span class="line">int(<span class="string">'101010'</span>, <span class="number">2</span>)  <span class="comment"># int('0b101010', 0)</span></span><br><span class="line">int(<span class="string">'37621'</span>, <span class="number">8</span>)  <span class="comment"># int('0o37621', 0)</span></span><br><span class="line">int(<span class="string">'23abcf'</span>, <span class="number">16</span>)  <span class="comment"># int('0x23abcf', 0)</span></span><br></pre></td></tr></table></figure>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;  <span class="comment"># 右移：向右移1位可以看成除以2</span></span><br><span class="line">&lt;&lt;  <span class="comment"># 左移：向左移一位可以看成乘以2</span></span><br><span class="line">&amp;   <span class="comment"># 与</span></span><br><span class="line">|   <span class="comment"># 或</span></span><br><span class="line">~   <span class="comment"># 取反：效果是对n的内部表示的每一位求补</span></span><br><span class="line">^   <span class="comment"># 异或</span></span><br></pre></td></tr></table></figure>
<h4 id="交换元素"><a href="#交换元素" class="headerlink" title="交换元素"></a>交换元素</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通常写法</span></span><br><span class="line">a=<span class="number">1</span></span><br><span class="line">b=<span class="number">2</span></span><br><span class="line">a,b = b,a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组元素交换</span></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">l[<span class="number">3</span>], l[<span class="number">1</span>] = l[<span class="number">1</span>], l[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 但是要同时交换数组和index就不行了</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line">i, l[i] = l[i], <span class="number">7</span>  <span class="comment"># 失败：这里不能用这种写法，因为修改了i的值之后，等号前面的self.p[i]就会立刻指向修改后的i的位置。这里和普通的a b交换有区别</span></span><br><span class="line">l[i], i = <span class="number">7</span>, l[i]  <span class="comment"># 等号后面的l[i]实际上是值传递</span></span><br></pre></td></tr></table></figure>
<h4 id="整数的最大值和最小值"><a href="#整数的最大值和最小值" class="headerlink" title="整数的最大值和最小值"></a>整数的最大值和最小值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">max_value = sys.maxsize</span><br><span class="line">min_value = -sys.maxsize - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">max_value = float(<span class="string">'inf'</span>)</span><br><span class="line">min_value = float(<span class="string">'-inf'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string   <span class="comment"># 导入string这个模块</span></span><br><span class="line">print(string.digits)  <span class="comment"># 输出包含数字0~9的字符串</span></span><br><span class="line">print(string.ascii_letters)  <span class="comment"># 包含所有字母(大写或小写)的字符串</span></span><br><span class="line">print(string.ascii_lowercase)  <span class="comment"># 包含所有小写字母的字符串</span></span><br><span class="line">print(string.ascii_uppercase)  <span class="comment"># 包含所有大写字母的字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##############</span></span><br><span class="line"><span class="number">0123456789</span></span><br><span class="line">abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">65</span>, <span class="number">91</span>)])  <span class="comment"># 所有大写字母</span></span><br><span class="line">print([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">97</span>, <span class="number">123</span>)])  <span class="comment"># 所有小写字母</span></span><br><span class="line">print([chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">48</span>, <span class="number">58</span>)])   <span class="comment"># 所有数字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">####################</span></span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>, <span class="string">'K'</span>, <span class="string">'L'</span>, <span class="string">'M'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>, <span class="string">'W'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span>]</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>, <span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line">[<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉空格的三个函数</span></span><br><span class="line">&gt;&gt;&gt;a=<span class="string">" gho stwwl "</span></span><br><span class="line">&gt;&gt;&gt;a.lstrip()</span><br><span class="line"><span class="string">'gho stwwl '</span></span><br><span class="line">&gt;&gt;&gt;a.rstrip()</span><br><span class="line"><span class="string">' gho stwwl'</span></span><br><span class="line">&gt;&gt;&gt;a.strip()</span><br><span class="line"><span class="string">'gho stwwl'</span></span><br></pre></td></tr></table></figure>
<h4 id="f-string"><a href="#f-string" class="headerlink" title="f-string"></a>f-string</h4><p><a href="https://blog.csdn.net/sunxb10/article/details/81036693" target="_blank" rel="noopener">https://blog.csdn.net/sunxb10/article/details/81036693</a></p>
<p>合并字典：<a href="https://blog.csdn.net/shanliangliuxing/article/details/7757089" target="_blank" rel="noopener">https://blog.csdn.net/shanliangliuxing/article/details/7757089</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Python学习-lru-cache/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Python学习-lru-cache/" class="post-title-link" itemprop="url">Python学习-lru_cache</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-05-28 09:48:49 / 修改时间：09:49:40" itemprop="dateCreated datePublished" datetime="2020-05-28T09:48:49+08:00">2020-05-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Java学习-Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Java学习-Thread/" class="post-title-link" itemprop="url">Java学习-Thread</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 19:17:33" itemprop="dateCreated datePublished" datetime="2020-05-24T19:17:33+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-12 09:57:34" itemprop="dateModified" datetime="2020-06-12T09:57:34+08:00">2020-06-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA学习/" itemprop="url" rel="index"><span itemprop="name">JAVA学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="线程的基本概念"><a href="#线程的基本概念" class="headerlink" title="线程的基本概念"></a>线程的基本概念</h4><p>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1–n个线程。（进程是资源分配的最小单位）<br>线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>创建、就绪、运行、阻塞、终止</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf4q1vrvkuj30fa0awaal.jpg" alt></p>
<ol>
<li>创建：新创建的一个线程对象</li>
<li>就绪：线程对象创建成功后，其他的线程调用该对象的start方法。该状态的线程位于可运行线程池内，变的可运行，等待获取CPU的使用权呢</li>
<li>运行：就绪状态的线程获取了CPU使用权，执行程序代码</li>
<li>阻塞：阻塞状态是线程因为某种原因放弃了CPU使用权，暂停运行。直到线程再次进入就绪状态，才有机会转到运行状态。阻塞的情况分为以下三种：<ol>
<li>等待阻塞：运行的线程执行wait方法，JVM会把该线程放入等待池中<strong>(wait会释放持有的锁)</strong></li>
<li>同步阻塞：运行的线程在获取对象同步锁的时，如果该同步锁被别的线程占用，则JVM会把改线程放入锁池中</li>
<li>其他阻塞：运行的线程执行sleep或join方法，或者发出了I/O(文件读写、网络请求)请求，JVM会把该线程置为阻塞状态。当sleep状态超时、join等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态<strong>(sleep不会释放持有的锁)</strong></li>
</ol>
</li>
<li>终止：线程执行完了或者因异常推出了run方法，该线程结束生命周期</li>
</ol>
<p>线程创建和切换的代价：<a href="https://www.jianshu.com/p/ece1bb5fa88b" target="_blank" rel="noopener">https://www.jianshu.com/p/ece1bb5fa88b</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Java学习-并发编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Java学习-并发编程/" class="post-title-link" itemprop="url">Java学习-并发编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 18:46:42" itemprop="dateCreated datePublished" datetime="2020-05-24T18:46:42+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-12 17:35:48" itemprop="dateModified" datetime="2021-04-12T17:35:48+08:00">2021-04-12</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA并发编程/" itemprop="url" rel="index"><span itemprop="name">JAVA并发编程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="整体脑图"><a href="#整体脑图" class="headerlink" title="整体脑图"></a>整体脑图</h4><p><img src="/images/chenssy_juc_201712.png"></p>
<p>并发编程领域可以抽象成三个核心问题：<strong>分工、同步和互斥</strong></p>
<h4 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h4><p>不同的线程负责不同的任务，可以并发的执行</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><ul>
<li><a href="/post/JAVA并发编程-1-内存模型">JAVA并发编程-1-内存模型</a></li>
<li><a href="/post/JAVA并发编程-2-并发基础">JAVA并发编程-2-并发基础</a></li>
<li><a href="/post/JAVA并发编程-3-锁">JAVA并发编程-3-锁</a></li>
<li><a href="/post/JAVA并发编程-4-并发工具类">JAVA并发编程-4-并发工具类</a></li>
<li><a href="/post/JAVA并发编程-5-其他">JAVA并发编程-5-ThreadLocal&amp;Fork&amp;Join</a></li>
<li><a href="/post/JAVA并发编程-6-并发集合">JAVA并发编程-6-并发集合</a></li>
<li><a href="/post/JAVA并发编程-7-Atomic">JAVA并发编程-7-Atomic</a></li>
<li><a href="/post/JAVA并发编程-8-阻塞队列">JAVA并发编程-8-阻塞队列</a></li>
<li><a href="/post/JAVA并发编程-9-线程池">JAVA并发编程-9-线程池</a></li>
<li><a href="/post/JAVA并发编程-10-响应式编程-RxJava">JAVA并发编程-10-响应式编程-RxJava</a></li>
<li><a href="/post/JAVA并发编程-12-并发框架-Disruptor">JAVA并发编程-12-并发框架-Disruptor</a></li>
<li></li>
</ul>
<p><a href="https://www.twle.cn/c/yufei/javatm/javatm-basic-executorservice.html" target="_blank" rel="noopener">疑问秒懂系列</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://ws2823147532.github.io/ws-site/post/Java学习-JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="王尚">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="努力，奋斗">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/post/Java学习-JVM/" class="post-title-link" itemprop="url">Java学习-JVM</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-24 18:42:22" itemprop="dateCreated datePublished" datetime="2020-05-24T18:42:22+08:00">2020-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-11 16:23:18" itemprop="dateModified" datetime="2020-12-11T16:23:18+08:00">2020-12-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA学习/" itemprop="url" rel="index"><span itemprop="name">JAVA学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.md" target="_blank" rel="noopener">转载地址 : JavaGuide</a></p>
<p>点击关注<a href="#公众号">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p>
<h1 id="Java-内存区域详解"><a href="#Java-内存区域详解" class="headerlink" title="Java 内存区域详解"></a>Java 内存区域详解</h1><p>如果没有特殊说明，都是针对的是 HotSpot 虚拟机。</p>
<h2 id="写在前面-常见面试题"><a href="#写在前面-常见面试题" class="headerlink" title="写在前面 (常见面试题)"></a>写在前面 (常见面试题)</h2><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><ul>
<li><strong>介绍下 Java 内存区域（运行时数据区）</strong></li>
<li><strong>Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）</strong></li>
<li><strong>对象的访问定位的两种方式（句柄和直接指针两种方式）</strong></li>
</ul>
<h3 id="拓展问题"><a href="#拓展问题" class="headerlink" title="拓展问题"></a>拓展问题</h3><ul>
<li><strong>String 类和常量池</strong></li>
<li><strong>8 种基本类型的包装类和常量池</strong></li>
</ul>
<h2 id="一-概述"><a href="#一-概述" class="headerlink" title="一 概述"></a>一 概述</h2><p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。</p>
<h2 id="二-运行时数据区域"><a href="#二-运行时数据区域" class="headerlink" title="二 运行时数据区域"></a>二 运行时数据区域</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，下面会介绍到。</p>
<p><strong>JDK 1.8 之前：</strong></p>
<p><img src="/images/before-jdk-1.8-jvm.png" alt="before-jdk-1.8-jvm"></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><img src="/images/jdk-1.8-jvm.png" alt="jdk-1.8-jvm"></p>
<p><strong>线程私有的：</strong>不会带来并发问题</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong>在并发问题中主要解决的就是内存共享问题，其中最主要的是堆内存的管理</p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<blockquote>
<p>疑问：线程私有的内存占用是JVM管理的内存的哪一部分？</p>
<p>Xss参数是设定虚拟机中每个线程占用的栈内存大小，而<code>虚拟机栈可分配的内存</code>又跟物理机的内存大小、Java堆内存、方法区(JDK1.7及以前)等内存大小相关，其它的区分得的内存越大，虚拟机栈能够分得的内存就越小，并发的线程数量也就越小————这句话是对的吗？</p>
<p>测试：单线程 启动参数 -Xss16m -Xms2m -Xmx2m，stack depth:415910 报了StackOverflowError</p>
</blockquote>
<h3 id="2-1-程序计数器"><a href="#2-1-程序计数器" class="headerlink" title="2.1 程序计数器"></a>2.1 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p>
<h3 id="2-2-Java-虚拟机栈"><a href="#2-2-Java-虚拟机栈" class="headerlink" title="2.2 Java 虚拟机栈"></a>2.2 Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：StackOverFlowError 和 OutOfMemoryError。</strong><a href="/post/Java学习-常见异常#StackOverflowError和OutOfMemoryError的区别">二者差异</a></p>
<ul>
<li><strong>StackOverFlowError：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 错误。</li>
</ul>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<blockquote>
<p><strong>疑问：虚拟机栈到底是占用的哪块内存呢？JVM直接开辟的系统内存空间，还是会共享heap空间？由于每次创建线程，都会创建其对应的虚拟机栈，那么线程创建太多会带来极大的内存消耗代价(以及线程切换代价)</strong></p>
<p>做了一个实验：</p>
<p>​    -Xss4m -Xms8m -Xmx8m：stack depth:215835 报了java.lang.StackOverflowError</p>
<p>​    -Xss16m -Xms8m -Xmx8m：stack depth:416734 报了java.lang.StackOverflowError</p>
<p>​    -Xss32m -Xms8m -Xmx8m：stack depth:835116 报了java.lang.StackOverflowError</p>
<p>从实验结果来看，限制了内存大小之后，改变虚拟机栈大小，无论把虚拟机栈设置多大，最终都是报的java.lang.StackOverflowError，是不是可以得出这样的结论，hotspot的设计中虚拟机栈使用的是独立于java堆内存的系统空间呢？</p>
</blockquote>
<h3 id="2-3-本地方法栈"><a href="#2-3-本地方法栈" class="headerlink" title="2.3 本地方法栈"></a>2.3 本地方法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h3 id="2-4-堆"><a href="#2-4-堆" class="headerlink" title="2.4 堆"></a>2.4 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p><strong>Java世界中“几乎”所有的对象都在堆中分配，但是，随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启<code>逃逸分析</code>，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</strong></p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用<code>分代垃圾收集算法</code>，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/JVM堆内存结构-JDK7.jpg" alt="JVM堆内存结构-JDK7"></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/JVM堆内存结构-jdk8.jpg" alt="JVM堆内存结构-JDK8"></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加  1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<blockquote>
<p>修正（<a href="https://github.com/Snailclimb/JavaGuide/issues/552" target="_blank" rel="noopener">issue552</a>）：“Hotspot遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了survivor区的一半时，取这个年龄和MaxTenuringThreshold中更小的一个值，作为新的晋升年龄阈值”。</p>
<p><strong>动态年龄计算的代码如下</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function">uint <span class="title">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="keyword">size_t</span> survivor_capacity)</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="comment">//survivor_capacity是survivor空间的大小</span></span><br><span class="line">&gt;   <span class="keyword">size_t</span> desired_survivor_size = (<span class="keyword">size_t</span>)((((<span class="keyword">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line">&gt;   <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">&gt;   uint age = <span class="number">1</span>;</span><br><span class="line">&gt;   <span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">&gt;     total += sizes[age];<span class="comment">//sizes数组是每个年龄段对象大小</span></span><br><span class="line">&gt;     <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">&gt;     age++;</span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt;   uint result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line">&gt; 	...</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;<br>&gt;</p>
<p>堆这里最容易出现的就是  OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当JVM花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发<code>java.lang.OutOfMemoryError: Java heap space</code> 错误。(和本机物理内存无关，和你配置的内存大小有关！)</li>
<li>……</li>
</ol>
<h3 id="2-5-方法区"><a href="#2-5-方法区" class="headerlink" title="2.5 方法区"></a>2.5 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h4 id="2-5-1-方法区和永久代的关系"><a href="#2-5-1-方法区和永久代的关系" class="headerlink" title="2.5.1 方法区和永久代的关系"></a>2.5.1 方法区和永久代的关系</h4><blockquote>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。  <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
</blockquote>
<h4 id="2-5-2-常用参数"><a href="#2-5-2-常用参数" class="headerlink" title="2.5.2 常用参数"></a>2.5.2 常用参数</h4><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N <span class="comment">//方法区 (永久代) 初始大小</span></span><br><span class="line">-XX:MaxPermSize=N <span class="comment">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span><br></pre></td></tr></table></figure>
<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure>
<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h4 id="2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#2-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?"></a>2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h4><ol>
<li>整个永久代有一个 JVM 本身设置固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。<blockquote>
<p>当你元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
</li>
</ol>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。  </p>
<ol>
<li><p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。  </p>
</li>
<li><p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h3 id="2-6-运行时常量池"><a href="#2-6-运行时常量池" class="headerlink" title="2.6 运行时常量池"></a>2.6 运行时常量池</h3><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<p><del><strong>JDK1.7 及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></del> </p>
<blockquote>
<p>修正(<a href="https://github.com/Snailclimb/JavaGuide/issues/747" target="_blank" rel="noopener">issue747</a>，<a href="https://blog.csdn.net/q5706503/article/details/84640762" target="_blank" rel="noopener">reference</a>)： </p>
<ol>
<li><strong>JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时hotspot虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 <code>字符串常量池</code>被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是hotspot中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong> </li>
</ol>
<p>实验：以下三组参数分别运行同一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">&gt;         List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">&gt;         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">&gt;         <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">&gt;             list.add(String.valueOf(i++).intern());</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>JDK1.6 -XX:PermSize=20M -XX:MaxPermSize=20M设置永久区大小，报OutOfMemoryError： PermGen space，说明字符串常量位于PermGen</p>
<p>JDK1.7 -XX:PermSize=20M -XX:MaxPermSize=20M设置永久区大小，OutOfMemoryError： Java heap space，说明字符串常量位于了heap内</p>
<p>JDK1.8 -XX:MetaspaceSize=20M -XX:MaxMetaspaceSize=20M设置永久区大小，OutOfMemoryError： Java heap space，说明字符串常量还在heap内</p>
</blockquote>
<p>相关问题：JVM 常量池中存储的是对象还是引用呢？： <a href="https://www.zhihu.com/question/57109429/answer/151717241" target="_blank" rel="noopener">https://www.zhihu.com/question/57109429/answer/151717241</a>  by RednaxelaFX</p>
<h3 id="2-7-直接内存"><a href="#2-7-直接内存" class="headerlink" title="2.7 直接内存"></a>2.7 直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。<a href="/post/java网络编程-零拷贝">这就是网络编程中常说的Zero-copy(零拷贝)</a></p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h2 id="三-HotSpot-虚拟机对象探秘"><a href="#三-HotSpot-虚拟机对象探秘" class="headerlink" title="三 HotSpot 虚拟机对象探秘"></a>三 HotSpot 虚拟机对象探秘</h2><p>通过上面的介绍我们大概知道了虚拟机的内存情况，下面我们来详细的了解一下 HotSpot 虚拟机在 Java 堆中对象分配、布局和访问的全过程。</p>
<h3 id="3-1-对象的创建"><a href="#3-1-对象的创建" class="headerlink" title="3.1 对象的创建"></a>3.1 对象的创建</h3><p>下图便是 Java 对象的创建过程，我建议最好是能默写出来，并且要掌握每一步在做什么。<br><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/Java创建对象的过程.png" alt="Java创建对象的过程"></p>
<h4 id="Step1-类加载检查"><a href="#Step1-类加载检查" class="headerlink" title="Step1:类加载检查"></a>Step1:类加载检查</h4><p> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h4 id="Step2-分配内存"><a href="#Step2-分配内存" class="headerlink" title="Step2:分配内存"></a>Step2:分配内存</h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p>
<p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/内存分配的两种方式.png" alt="内存分配的两种方式"></p>
<p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h4 id="Step3-初始化零值"><a href="#Step3-初始化零值" class="headerlink" title="Step3:初始化零值"></a>Step3:初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h4 id="Step4-设置对象头"><a href="#Step4-设置对象头" class="headerlink" title="Step4:设置对象头"></a>Step4:设置对象头</h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h4 id="Step5-执行-init-方法"><a href="#Step5-执行-init-方法" class="headerlink" title="Step5:执行 init 方法"></a>Step5:执行 init 方法</h4><p> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h3 id="3-2-对象的内存布局"><a href="#3-2-对象的内存布局" class="headerlink" title="3.2 对象的内存布局"></a>3.2 对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h3 id="3-3-对象的访问定位"><a href="#3-3-对象的访问定位" class="headerlink" title="3.3 对象的访问定位"></a>3.3 对象的访问定位</h3><p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p>
<ol>
<li><p><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/对象的访问定位-使用句柄.png" alt="对象的访问定位-使用句柄"></p>
</li>
<li><p><strong>直接指针：</strong>  如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。</p>
</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/对象的访问定位-直接指针.png" alt="对象的访问定位-直接指针"></p>
<p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p>
<h2 id="四-重点补充内容"><a href="#四-重点补充内容" class="headerlink" title="四  重点补充内容"></a>四  重点补充内容</h2><h3 id="4-1-String-类和常量池"><a href="#4-1-String-类和常量池" class="headerlink" title="4.1 String 类和常量池"></a>4.1 String 类和常量池</h3><p><strong>String 对象的两种创建方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;<span class="comment">//先检查字符串常量池中有没有"abcd"，如果字符串常量池中没有，则创建一个，然后 str1 指向字符串常量池中的对象，如果有，则直接将 str1 指向"abcd""；</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);<span class="comment">//堆中创建一个新的对象</span></span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str2==str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>这两种不同的创建方法是有差别的。</p>
<ul>
<li>第一种方式是在常量池中拿对象；</li>
<li>第二种方式是直接在堆内存空间创建一个新的对象。</li>
</ul>
<p>记住一点：<strong>只要使用 new 方法，便需要创建新的对象。</strong></p>
<p>再给大家一个图应该更容易理解，图片来源：<a href="https://www.journaldev.com/797/what-is-java-string-pool" target="_blank" rel="noopener">https://www.journaldev.com/797/what-is-java-string-pool</a>：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-3String-Pool-Java1-450x249.png" alt="String-Pool-Java"></p>
<p><strong>String 类型的常量池比较特殊。它的主要使用方法有两种：</strong></p>
<ul>
<li>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</li>
<li>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法。String.intern() 是一个 Native 方法，它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用；如果没有，JDK1.7之前（不包含1.7）的处理方式是在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用，JDK1.7以及之后的处理方式是在常量池中记录此字符串的引用，并返回该引用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的 String 对象一个是常量池中的 String 对象，</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的 String 对象</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串拼接:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"str"</span>;</span><br><span class="line">String str2 = <span class="string">"ing"</span>;</span><br><span class="line">		 </span><br><span class="line">String str3 = <span class="string">"str"</span> + <span class="string">"ing"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str4 = str1 + str2; <span class="comment">//在堆上创建的新的对象	  </span></span><br><span class="line">String str5 = <span class="string">"string"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">//false</span></span><br><span class="line">System.out.println(str3 == str5);<span class="comment">//true</span></span><br><span class="line">System.out.println(str4 == str5);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-7/字符串拼接-常量池2.png" alt="字符串拼接"></p>
<p>尽量避免多个字符串拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 StringBuilder 或者 StringBuffer。</p>
<h3 id="4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？"><a href="#4-2-String-s1-new-String-“abc”-这句话创建了几个字符串对象？" class="headerlink" title="4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？"></a>4.2 String s1 = new String(“abc”);这句话创建了几个字符串对象？</h3><p><strong>将创建 1 或 2 个字符串。如果池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。如果池中没有字符串常量“abc”，那么它将首先在池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</strong></p>
<p><strong>验证：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"abc"</span>);<span class="comment">// 堆内存的地址值</span></span><br><span class="line">String s2 = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// 输出 false,因为一个是堆内存，一个是常量池的内存，故两者是不同的。</span></span><br><span class="line">System.out.println(s1.equals(s2));<span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure>
<h3 id="4-3-8-种基本类型的包装类和常量池"><a href="#4-3-8-种基本类型的包装类和常量池" class="headerlink" title="4.3 8 种基本类型的包装类和常量池"></a>4.3 8 种基本类型的包装类和常量池</h3><p><strong>Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character创建了数值在[0,127]范围的缓存数据，Boolean 直接返回True Or False。如果超出对应范围仍然会去创建新的对象。</strong> 为啥把缓存设置为[-128，127]区间？（<a href="https://github.com/Snailclimb/JavaGuide/issues/461" target="_blank" rel="noopener">参见issue/461</a>）性能和资源之间的权衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? TRUE : FALSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterCache</span> </span>&#123;         </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CharacterCache</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">          </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Character cache[] = <span class="keyword">new</span> Character[<span class="number">127</span> + <span class="number">1</span>];          </span><br><span class="line">    <span class="keyword">static</span> &#123;             </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)                 </span><br><span class="line">            cache[i] = <span class="keyword">new</span> Character((<span class="keyword">char</span>)i);         </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两种浮点数类型的包装类 Float,Double 并没有实现常量池技术。**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">33</span>;</span><br><span class="line">Integer i2 = <span class="number">33</span>;</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">// 输出 true</span></span><br><span class="line">Integer i11 = <span class="number">333</span>;</span><br><span class="line">Integer i22 = <span class="number">333</span>;</span><br><span class="line">System.out.println(i11 == i22);<span class="comment">// 输出 false</span></span><br><span class="line">Double i3 = <span class="number">1.2</span>;</span><br><span class="line">Double i4 = <span class="number">1.2</span>;</span><br><span class="line">System.out.println(i3 == i4);<span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p><strong>Integer 缓存源代码：</strong> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>应用场景：</strong></p>
<ol>
<li>Integer i1=40；Java 在编译的时候会直接将代码封装成 Integer i1=Integer.valueOf(40);，从而使用常量池中的对象。</li>
<li>Integer i1 = new Integer(40);这种情况下会创建新的对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<p><strong>Integer 比较更丰富的一个例子:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i1=i2   true</span><br><span class="line">i1=i2+i3   true</span><br><span class="line">i1=i4   false</span><br><span class="line">i4=i5   false</span><br><span class="line">i4=i5+i6   true</span><br><span class="line">40=i5+i6   true</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>语句 i4 == i5 + i6，因为+这个操作符不适用于 Integer 对象，首先 i5 和 i6 进行自动拆箱操作，进行数值相加，即 i4 == 40。然后 Integer 对象无法与数值进行直接比较，所以 i4 自动拆箱转为 int 值 40，最终这条语句转为 40 == 40 进行数值比较。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版》</li>
<li>《实战 java 虚拟机》</li>
<li><a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/index.html</a></li>
<li><a href="http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/" target="_blank" rel="noopener">http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/</a></li>
<li><a href="https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou" target="_blank" rel="noopener">https://dzone.com/articles/jvm-permgen-%E2%80%93-where-art-thou</a></li>
<li><a href="https://stackoverflow.com/questions/9095748/method-area-and-permgen" target="_blank" rel="noopener">https://stackoverflow.com/questions/9095748/method-area-and-permgen</a></li>
<li>深入解析String#intern<a href="https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html" target="_blank" rel="noopener">https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html</a></li>
</ul>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#公众号">公众号</a>后台回复 <strong>“Java面试突击”</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源<a href="#公众号">公众号</a>后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。 </p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">王尚</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">194</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">148</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">王尚</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>

  <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three.min.js"></script>
    <script defer src="//cdn.jsdelivr.net/gh/theme-next/theme-next-three@1/three-waves.min.js"></script>


  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdnjs.cloudflare.com/ajax/libs/mermaid/8.4.8/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>